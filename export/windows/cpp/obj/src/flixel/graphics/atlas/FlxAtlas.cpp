// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_atlas_FlxAtlas
#include <flixel/graphics/atlas/FlxAtlas.h>
#endif
#ifndef INCLUDED_flixel_graphics_atlas_FlxNode
#include <flixel/graphics/atlas/FlxNode.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxTileFrames
#include <flixel/graphics/frames/FlxTileFrames.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_system_FlxAssets
#include <flixel/system/FlxAssets.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SignalFrontEnd
#include <flixel/system/frontEnds/SignalFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_FlxBitmapDataUtil
#include <flixel/util/FlxBitmapDataUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxRect
#include <flixel/util/FlxPool_flixel_math_FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxSignal
#include <flixel/util/IFlxSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxBaseSignal
#include <flixel/util/_FlxSignal/FlxBaseSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal1
#include <flixel/util/_FlxSignal/FlxSignal1.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BlendMode
#include <openfl/_legacy/display/BlendMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Point
#include <openfl/_legacy/geom/Point.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Rectangle
#include <openfl/_legacy/geom/Rectangle.h>
#endif

namespace flixel{
namespace graphics{
namespace atlas{

void FlxAtlas_obj::__construct(::String name,hx::Null< Bool >  __o_powerOfTwo,hx::Null< Int >  __o_border,hx::Null< Bool >  __o_rotate, ::flixel::math::FlxPoint minSize, ::flixel::math::FlxPoint maxSize){
Bool powerOfTwo = __o_powerOfTwo.Default(false);
Int border = __o_border.Default(1);
Bool rotate = __o_rotate.Default(false);
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","new",0xc05046bf,"flixel.graphics.atlas.FlxAtlas.new","flixel/graphics/atlas/FlxAtlas.hx",25,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(name,"name")
            	HX_STACK_ARG(powerOfTwo,"powerOfTwo")
            	HX_STACK_ARG(border,"border")
            	HX_STACK_ARG(rotate,"rotate")
            	HX_STACK_ARG(minSize,"minSize")
            	HX_STACK_ARG(maxSize,"maxSize")
HXLINE( 111)		this->powerOfTwo = false;
HXLINE( 106)		this->allowRotation = false;
HXLINE( 101)		this->maxHeight = (int)1024;
HXLINE(  97)		this->maxWidth = (int)1024;
HXLINE(  92)		this->minHeight = (int)128;
HXLINE(  88)		this->minWidth = (int)128;
HXLINE(  71)		this->border = (int)1;
HXLINE(  66)		this->persist = false;
HXLINE( 131)		this->nodes =  ::haxe::ds::StringMap_obj::__new();
HXLINE( 132)		this->name = name;
HXLINE( 133)		this->set_powerOfTwo(powerOfTwo);
HXLINE( 134)		this->border = border;
HXLINE( 136)		Bool _hx_tmp = hx::IsNotNull( minSize );
HXDLIN( 136)		if (_hx_tmp) {
HXLINE( 136)			minSize = minSize;
            		}
            		else {
HXLINE( 136)			minSize = ::flixel::graphics::atlas::FlxAtlas_obj::defaultMinSize;
            		}
HXLINE( 137)		Bool _hx_tmp1 = hx::IsNotNull( maxSize );
HXDLIN( 137)		if (_hx_tmp1) {
HXLINE( 137)			maxSize = maxSize;
            		}
            		else {
HXLINE( 137)			maxSize = ::flixel::graphics::atlas::FlxAtlas_obj::defaultMaxSize;
            		}
HXLINE( 139)		Int _hx_tmp2 = ::Std_obj::_hx_int(minSize->x);
HXDLIN( 139)		this->set_minWidth(_hx_tmp2);
HXLINE( 140)		Int _hx_tmp3 = ::Std_obj::_hx_int(minSize->y);
HXDLIN( 140)		this->set_minHeight(_hx_tmp3);
HXLINE( 141)		Int _hx_tmp4;
HXDLIN( 141)		Bool _hx_tmp5 = (maxSize->x > minSize->x);
HXDLIN( 141)		if (_hx_tmp5) {
HXLINE( 141)			_hx_tmp4 = ::Std_obj::_hx_int(maxSize->x);
            		}
            		else {
HXLINE( 141)			_hx_tmp4 = this->minWidth;
            		}
HXDLIN( 141)		this->set_maxWidth(_hx_tmp4);
HXLINE( 142)		Int _hx_tmp6;
HXDLIN( 142)		Bool _hx_tmp7 = (maxSize->y > minSize->x);
HXDLIN( 142)		if (_hx_tmp7) {
HXLINE( 142)			_hx_tmp6 = ::Std_obj::_hx_int(maxSize->y);
            		}
            		else {
HXLINE( 142)			_hx_tmp6 = this->minHeight;
            		}
HXDLIN( 142)		this->set_maxHeight(_hx_tmp6);
HXLINE( 143)		this->allowRotation = rotate;
HXLINE( 145)		this->initRoot();
HXLINE( 147)		::flixel::FlxG_obj::signals->preStateCreate->add(this->onClear_dyn());
            	}

Dynamic FlxAtlas_obj::__CreateEmpty() { return new FlxAtlas_obj; }

hx::ObjectPtr< FlxAtlas_obj > FlxAtlas_obj::__new(::String name,hx::Null< Bool >  __o_powerOfTwo,hx::Null< Int >  __o_border,hx::Null< Bool >  __o_rotate, ::flixel::math::FlxPoint minSize, ::flixel::math::FlxPoint maxSize)
{
	hx::ObjectPtr< FlxAtlas_obj > _hx_result = new FlxAtlas_obj();
	_hx_result->__construct(name,__o_powerOfTwo,__o_border,__o_rotate,minSize,maxSize);
	return _hx_result;
}

Dynamic FlxAtlas_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxAtlas_obj > _hx_result = new FlxAtlas_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5]);
	return _hx_result;
}

static ::flixel::util::IFlxDestroyable_obj _hx_flixel_graphics_atlas_FlxAtlas__hx_flixel_util_IFlxDestroyable= {
	( void (hx::Object::*)())&::flixel::graphics::atlas::FlxAtlas_obj::destroy,
};

void *FlxAtlas_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xd4fe2fcd: return &_hx_flixel_graphics_atlas_FlxAtlas__hx_flixel_util_IFlxDestroyable;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void FlxAtlas_obj::initRoot(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","initRoot",0x37652e93,"flixel.graphics.atlas.FlxAtlas.initRoot","flixel/graphics/atlas/FlxAtlas.hx",151,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 152)		HX_VARI( Int,rootWidth) = this->minWidth;
HXLINE( 153)		HX_VARI( Int,rootHeight) = this->minHeight;
HXLINE( 155)		Bool _hx_tmp = this->powerOfTwo;
HXDLIN( 155)		if (_hx_tmp) {
HXLINE( 157)			rootWidth = this->getNextPowerOfTwo(rootWidth);
HXLINE( 158)			rootHeight = this->getNextPowerOfTwo(rootHeight);
            		}
HXLINE( 161)		HX_VARI(  ::flixel::math::FlxRect,_this) = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 161)		_this->x = (int)0;
HXDLIN( 161)		_this->y = (int)0;
HXDLIN( 161)		_this->width = rootWidth;
HXDLIN( 161)		_this->height = rootHeight;
HXDLIN( 161)		_this->_inPool = false;
HXDLIN( 161)		this->root =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,initRoot,(void))

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::addNode( ::Dynamic Graphic,::String Key){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","addNode",0xeec7dea2,"flixel.graphics.atlas.FlxAtlas.addNode","flixel/graphics/atlas/FlxAtlas.hx",171,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Graphic,"Graphic")
            	HX_STACK_ARG(Key,"Key")
HXLINE( 172)		HX_VARI( ::String,key) = ::flixel::_hx_system::FlxAssets_obj::resolveKey(Graphic,Key);
HXLINE( 174)		Bool _hx_tmp = hx::IsNull( key );
HXDLIN( 174)		if (_hx_tmp) {
HXLINE( 177)			HX_STACK_DO_THROW(HX_("addNode can't find the key for specified bitmapdata. Please provide not null value as a Key argument.",92,54,24,2b));
            		}
HXLINE( 182)		Bool _hx_tmp1 = this->hasNodeWithName(key);
HXDLIN( 182)		if (_hx_tmp1) {
HXLINE( 183)			return this->nodes->get(key).StaticCast<  ::flixel::graphics::atlas::FlxNode >();
            		}
HXLINE( 185)		HX_VARI(  ::openfl::_legacy::display::BitmapData,data) = ::flixel::_hx_system::FlxAssets_obj::resolveBitmapData(Graphic);
HXLINE( 187)		Bool _hx_tmp2 = hx::IsNull( data );
HXDLIN( 187)		if (_hx_tmp2) {
HXLINE( 190)			HX_STACK_DO_THROW(((HX_("addNode can't find bitmapdata with specified key: ",bb,33,14,9a) + Graphic) + HX_(". Please provide valid value.",84,e6,88,32)));
            		}
HXLINE( 196)		Bool _hx_tmp3 = hx::IsNull( this->root->left );
HXDLIN( 196)		if (_hx_tmp3) {
HXLINE( 197)			return this->insertFirstNodeInRoot(data,key);
            		}
HXLINE( 199)		Bool _hx_tmp4 = hx::IsNull( this->root->right );
HXDLIN( 199)		if (_hx_tmp4) {
HXLINE( 201)			return this->expand(data,key);
            		}
HXLINE( 205)		HX_VARI(  ::flixel::graphics::atlas::FlxNode,inserted) = this->tryInsert(data,key);
HXLINE( 206)		Bool _hx_tmp5 = hx::IsNotNull( inserted );
HXDLIN( 206)		if (_hx_tmp5) {
HXLINE( 207)			return inserted;
            		}
HXLINE( 210)		this->wrapRoot();
HXLINE( 211)		return this->expand(data,key);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,addNode,return )

void FlxAtlas_obj::wrapRoot(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","wrapRoot",0x7e08124d,"flixel.graphics.atlas.FlxAtlas.wrapRoot","flixel/graphics/atlas/FlxAtlas.hx",215,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 216)		HX_VARI(  ::flixel::graphics::atlas::FlxNode,temp) = this->root;
HXLINE( 217)		Float Width = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN( 217)		Float Height = ::Std_obj::_hx_int(temp->rect->height);
HXDLIN( 217)		HX_VARI(  ::flixel::math::FlxRect,_this) = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 217)		_this->x = (int)0;
HXDLIN( 217)		_this->y = (int)0;
HXDLIN( 217)		_this->width = Width;
HXDLIN( 217)		_this->height = Height;
HXDLIN( 217)		_this->_inPool = false;
HXDLIN( 217)		this->root =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE( 218)		this->root->left = temp;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,wrapRoot,(void))

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::tryInsert( ::openfl::_legacy::display::BitmapData data,::String key){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","tryInsert",0xc0214673,"flixel.graphics.atlas.FlxAtlas.tryInsert","flixel/graphics/atlas/FlxAtlas.hx",222,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(data,"data")
            	HX_STACK_ARG(key,"key")
HXLINE( 223)		Int _hx_tmp = data->get_width();
HXDLIN( 223)		HX_VARI( Int,insertWidth) = (_hx_tmp + this->border);
HXLINE( 224)		Int _hx_tmp1 = data->get_height();
HXDLIN( 224)		HX_VARI( Int,insertHeight) = (_hx_tmp1 + this->border);
HXLINE( 226)		HX_VARI( Bool,rotateNode) = false;
HXLINE( 227)		HX_VARI(  ::flixel::graphics::atlas::FlxNode,nodeToInsert) = this->findNodeToInsert(insertWidth,insertHeight);
HXLINE( 229)		Bool _hx_tmp2 = this->allowRotation;
HXDLIN( 229)		if (_hx_tmp2) {
HXLINE( 231)			HX_VARI(  ::flixel::graphics::atlas::FlxNode,nodeToInsertWithRotation) = this->findNodeToInsert(insertHeight,insertWidth);
HXLINE( 233)			Bool _hx_tmp3 = hx::IsNotNull( nodeToInsertWithRotation );
HXDLIN( 233)			if (_hx_tmp3) {
HXLINE( 235)				Int _hx_tmp4 = ::Std_obj::_hx_int(nodeToInsertWithRotation->rect->width);
HXDLIN( 235)				Int _hx_tmp5 = ::Std_obj::_hx_int(nodeToInsertWithRotation->rect->height);
HXDLIN( 235)				HX_VARI( Int,nodeWithRotationArea) = (_hx_tmp4 * _hx_tmp5);
HXLINE( 237)				Bool _hx_tmp6;
HXDLIN( 237)				Bool _hx_tmp7 = hx::IsNotNull( nodeToInsert );
HXDLIN( 237)				if (_hx_tmp7) {
HXLINE( 237)					Bool _hx_tmp8 = hx::IsNotNull( nodeToInsert );
HXDLIN( 237)					if (_hx_tmp8) {
HXLINE( 237)						Int _hx_tmp9 = ::Std_obj::_hx_int(nodeToInsert->rect->width);
HXDLIN( 237)						Int _hx_tmp10 = ::Std_obj::_hx_int(nodeToInsert->rect->height);
HXDLIN( 237)						_hx_tmp6 = ((_hx_tmp9 * _hx_tmp10) > nodeWithRotationArea);
            					}
            					else {
HXLINE( 237)						_hx_tmp6 = false;
            					}
            				}
            				else {
HXLINE( 237)					_hx_tmp6 = true;
            				}
HXDLIN( 237)				if (_hx_tmp6) {
HXLINE( 239)					nodeToInsert = nodeToInsertWithRotation;
HXLINE( 240)					rotateNode = true;
HXLINE( 241)					HX_VARI( Int,temp) = insertWidth;
HXLINE( 242)					insertWidth = insertHeight;
HXLINE( 243)					insertHeight = temp;
            				}
            			}
            		}
HXLINE( 248)		Bool _hx_tmp11 = hx::IsNotNull( nodeToInsert );
HXDLIN( 248)		if (_hx_tmp11) {
HXLINE( 250)			HX_VARI( Bool,horizontally) = this->needToDivideHorizontally(nodeToInsert,insertWidth,insertHeight);
HXLINE( 251)			return this->divideNode(nodeToInsert,insertWidth,insertHeight,horizontally,data,key,rotateNode);
            		}
HXLINE( 254)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,tryInsert,return )

Bool FlxAtlas_obj::needToDivideHorizontally( ::flixel::graphics::atlas::FlxNode nodeToDivide,Int insertWidth,Int insertHeight){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","needToDivideHorizontally",0x28a8e09c,"flixel.graphics.atlas.FlxAtlas.needToDivideHorizontally","flixel/graphics/atlas/FlxAtlas.hx",258,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(nodeToDivide,"nodeToDivide")
            	HX_STACK_ARG(insertWidth,"insertWidth")
            	HX_STACK_ARG(insertHeight,"insertHeight")
HXLINE( 259)		Int _hx_tmp = ::Std_obj::_hx_int(nodeToDivide->rect->width);
HXDLIN( 259)		HX_VARI( Int,dw) = (_hx_tmp - insertWidth);
HXLINE( 260)		Int _hx_tmp1 = ::Std_obj::_hx_int(nodeToDivide->rect->height);
HXLINE( 262)		return (dw > (_hx_tmp1 - insertHeight));
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxAtlas_obj,needToDivideHorizontally,return )

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::divideNode( ::flixel::graphics::atlas::FlxNode nodeToDivide,Int insertWidth,Int insertHeight,Bool divideHorizontally, ::openfl::_legacy::display::BitmapData firstGrandChildData,::String firstGrandChildKey,hx::Null< Bool >  __o_firstGrandChildRotated){
Bool firstGrandChildRotated = __o_firstGrandChildRotated.Default(false);
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","divideNode",0x568bb99c,"flixel.graphics.atlas.FlxAtlas.divideNode","flixel/graphics/atlas/FlxAtlas.hx",266,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(nodeToDivide,"nodeToDivide")
            	HX_STACK_ARG(insertWidth,"insertWidth")
            	HX_STACK_ARG(insertHeight,"insertHeight")
            	HX_STACK_ARG(divideHorizontally,"divideHorizontally")
            	HX_STACK_ARG(firstGrandChildData,"firstGrandChildData")
            	HX_STACK_ARG(firstGrandChildKey,"firstGrandChildKey")
            	HX_STACK_ARG(firstGrandChildRotated,"firstGrandChildRotated")
HXLINE( 267)		Bool _hx_tmp = hx::IsNotNull( nodeToDivide );
HXDLIN( 267)		if (_hx_tmp) {
HXLINE( 269)			HX_VARI(  ::flixel::graphics::atlas::FlxNode,firstChild) = null();
HXLINE( 270)			HX_VARI(  ::flixel::graphics::atlas::FlxNode,secondChild) = null();
HXLINE( 271)			HX_VARI(  ::flixel::graphics::atlas::FlxNode,firstGrandChild) = null();
HXLINE( 272)			HX_VARI(  ::flixel::graphics::atlas::FlxNode,secondGrandChild) = null();
HXLINE( 273)			HX_VARI( Bool,firstGrandChildFilled) = hx::IsNotNull( firstGrandChildKey );
HXLINE( 275)			if (divideHorizontally) {
HXLINE( 277)				Float X = ::Std_obj::_hx_int(nodeToDivide->rect->x);
HXDLIN( 277)				Float Y = ::Std_obj::_hx_int(nodeToDivide->rect->y);
HXDLIN( 277)				Float Height = ::Std_obj::_hx_int(nodeToDivide->rect->height);
HXDLIN( 277)				HX_VARI(  ::flixel::math::FlxRect,_this) = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 277)				_this->x = X;
HXDLIN( 277)				_this->y = Y;
HXDLIN( 277)				_this->width = insertWidth;
HXDLIN( 277)				_this->height = Height;
HXDLIN( 277)				_this->_inPool = false;
HXDLIN( 277)				firstChild =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE( 279)				Int _hx_tmp1 = ::Std_obj::_hx_int(nodeToDivide->rect->width);
HXDLIN( 279)				if (((_hx_tmp1 - insertWidth) > (int)0)) {
HXLINE( 281)					Int _hx_tmp2 = ::Std_obj::_hx_int(nodeToDivide->rect->x);
HXDLIN( 281)					Float X1 = (_hx_tmp2 + insertWidth);
HXDLIN( 281)					Float Y1 = ::Std_obj::_hx_int(nodeToDivide->rect->y);
HXDLIN( 281)					Int _hx_tmp3 = ::Std_obj::_hx_int(nodeToDivide->rect->width);
HXDLIN( 281)					Float Width = (_hx_tmp3 - insertWidth);
HXDLIN( 281)					Float Height1 = ::Std_obj::_hx_int(nodeToDivide->rect->height);
HXDLIN( 281)					HX_VARI_NAME(  ::flixel::math::FlxRect,_this1,"_this") = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 281)					_this1->x = X1;
HXDLIN( 281)					_this1->y = Y1;
HXDLIN( 281)					_this1->width = Width;
HXDLIN( 281)					_this1->height = Height1;
HXDLIN( 281)					_this1->_inPool = false;
HXDLIN( 281)					secondChild =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this1,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            				}
HXLINE( 284)				Float X2 = ::Std_obj::_hx_int(firstChild->rect->x);
HXDLIN( 284)				Float Y2 = ::Std_obj::_hx_int(firstChild->rect->y);
HXDLIN( 284)				HX_VARI_NAME(  ::flixel::math::FlxRect,_this2,"_this") = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 284)				_this2->x = X2;
HXDLIN( 284)				_this2->y = Y2;
HXDLIN( 284)				_this2->width = insertWidth;
HXDLIN( 284)				_this2->height = insertHeight;
HXDLIN( 284)				_this2->_inPool = false;
HXDLIN( 284)				firstGrandChild =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this2,hx::ObjectPtr<OBJ_>(this),firstGrandChildFilled,firstGrandChildKey,firstGrandChildRotated);
HXLINE( 286)				Int _hx_tmp4 = ::Std_obj::_hx_int(firstChild->rect->height);
HXDLIN( 286)				if (((_hx_tmp4 - insertHeight) > (int)0)) {
HXLINE( 288)					Float X3 = ::Std_obj::_hx_int(firstChild->rect->x);
HXDLIN( 288)					Int _hx_tmp5 = ::Std_obj::_hx_int(firstChild->rect->y);
HXDLIN( 288)					Float Y3 = (_hx_tmp5 + insertHeight);
HXDLIN( 288)					Int _hx_tmp6 = ::Std_obj::_hx_int(firstChild->rect->height);
HXDLIN( 288)					Float Height2 = (_hx_tmp6 - insertHeight);
HXDLIN( 288)					HX_VARI_NAME(  ::flixel::math::FlxRect,_this3,"_this") = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 288)					_this3->x = X3;
HXDLIN( 288)					_this3->y = Y3;
HXDLIN( 288)					_this3->width = insertWidth;
HXDLIN( 288)					_this3->height = Height2;
HXDLIN( 288)					_this3->_inPool = false;
HXDLIN( 288)					secondGrandChild =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this3,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            				}
            			}
            			else {
HXLINE( 294)				Float X4 = ::Std_obj::_hx_int(nodeToDivide->rect->x);
HXDLIN( 294)				Float Y4 = ::Std_obj::_hx_int(nodeToDivide->rect->y);
HXDLIN( 294)				Float Width1 = ::Std_obj::_hx_int(nodeToDivide->rect->width);
HXDLIN( 294)				HX_VARI_NAME(  ::flixel::math::FlxRect,_this4,"_this") = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 294)				_this4->x = X4;
HXDLIN( 294)				_this4->y = Y4;
HXDLIN( 294)				_this4->width = Width1;
HXDLIN( 294)				_this4->height = insertHeight;
HXDLIN( 294)				_this4->_inPool = false;
HXDLIN( 294)				firstChild =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this4,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE( 296)				Int _hx_tmp7 = ::Std_obj::_hx_int(nodeToDivide->rect->height);
HXDLIN( 296)				if (((_hx_tmp7 - insertHeight) > (int)0)) {
HXLINE( 298)					Float X5 = ::Std_obj::_hx_int(nodeToDivide->rect->x);
HXDLIN( 298)					Int _hx_tmp8 = ::Std_obj::_hx_int(nodeToDivide->rect->y);
HXDLIN( 298)					Float Y5 = (_hx_tmp8 + insertHeight);
HXDLIN( 298)					Float Width2 = ::Std_obj::_hx_int(nodeToDivide->rect->width);
HXDLIN( 298)					Int _hx_tmp9 = ::Std_obj::_hx_int(nodeToDivide->rect->height);
HXDLIN( 298)					Float Height3 = (_hx_tmp9 - insertHeight);
HXDLIN( 298)					HX_VARI_NAME(  ::flixel::math::FlxRect,_this5,"_this") = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 298)					_this5->x = X5;
HXDLIN( 298)					_this5->y = Y5;
HXDLIN( 298)					_this5->width = Width2;
HXDLIN( 298)					_this5->height = Height3;
HXDLIN( 298)					_this5->_inPool = false;
HXDLIN( 298)					secondChild =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this5,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            				}
HXLINE( 301)				Float X6 = ::Std_obj::_hx_int(firstChild->rect->x);
HXDLIN( 301)				Float Y6 = ::Std_obj::_hx_int(firstChild->rect->y);
HXDLIN( 301)				HX_VARI_NAME(  ::flixel::math::FlxRect,_this6,"_this") = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 301)				_this6->x = X6;
HXDLIN( 301)				_this6->y = Y6;
HXDLIN( 301)				_this6->width = insertWidth;
HXDLIN( 301)				_this6->height = insertHeight;
HXDLIN( 301)				_this6->_inPool = false;
HXDLIN( 301)				firstGrandChild =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this6,hx::ObjectPtr<OBJ_>(this),firstGrandChildFilled,firstGrandChildKey,firstGrandChildRotated);
HXLINE( 303)				Int _hx_tmp10 = ::Std_obj::_hx_int(firstChild->rect->width);
HXDLIN( 303)				if (((_hx_tmp10 - insertWidth) > (int)0)) {
HXLINE( 305)					Int _hx_tmp11 = ::Std_obj::_hx_int(firstChild->rect->x);
HXDLIN( 305)					Float X7 = (_hx_tmp11 + insertWidth);
HXDLIN( 305)					Float Y7 = ::Std_obj::_hx_int(firstChild->rect->y);
HXDLIN( 305)					Int _hx_tmp12 = ::Std_obj::_hx_int(firstChild->rect->width);
HXDLIN( 305)					Float Width3 = (_hx_tmp12 - insertWidth);
HXDLIN( 305)					HX_VARI_NAME(  ::flixel::math::FlxRect,_this7,"_this") = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 305)					_this7->x = X7;
HXDLIN( 305)					_this7->y = Y7;
HXDLIN( 305)					_this7->width = Width3;
HXDLIN( 305)					_this7->height = insertHeight;
HXDLIN( 305)					_this7->_inPool = false;
HXDLIN( 305)					secondGrandChild =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this7,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
            				}
            			}
HXLINE( 309)			firstChild->left = firstGrandChild;
HXLINE( 310)			firstChild->right = secondGrandChild;
HXLINE( 312)			nodeToDivide->left = firstChild;
HXLINE( 313)			nodeToDivide->right = secondChild;
HXLINE( 316)			Bool _hx_tmp13;
HXDLIN( 316)			Bool _hx_tmp14 = hx::IsNotNull( firstGrandChildKey );
HXDLIN( 316)			if (_hx_tmp14) {
HXLINE( 316)				_hx_tmp13 = hx::IsNotNull( firstGrandChildData );
            			}
            			else {
HXLINE( 316)				_hx_tmp13 = false;
            			}
HXDLIN( 316)			if (_hx_tmp13) {
HXLINE( 318)				this->expandBitmapData();
HXLINE( 320)				if (firstGrandChildRotated) {
HXLINE( 322)					::flixel::graphics::atlas::FlxAtlas_obj::matrix->identity();
HXLINE( 323)					Float _hx_tmp15 = ((Float)::Math_obj::PI / (Float)(int)2);
HXDLIN( 323)					::flixel::graphics::atlas::FlxAtlas_obj::matrix->rotate(_hx_tmp15);
HXLINE( 324)					Int _hx_tmp16 = firstGrandChildData->get_height();
HXDLIN( 324)					Int _hx_tmp17 = ::Std_obj::_hx_int(firstGrandChild->rect->x);
HXDLIN( 324)					Int _hx_tmp18 = (_hx_tmp16 + _hx_tmp17);
HXDLIN( 324)					Int _hx_tmp19 = ::Std_obj::_hx_int(firstGrandChild->rect->y);
HXDLIN( 324)					::flixel::graphics::atlas::FlxAtlas_obj::matrix->translate(_hx_tmp18,_hx_tmp19);
HXLINE( 325)					this->bitmapData->draw(firstGrandChildData,::flixel::graphics::atlas::FlxAtlas_obj::matrix,null(),null(),null(),null());
            				}
            				else {
HXLINE( 329)					Int _hx_tmp20 = ::Std_obj::_hx_int(firstGrandChild->rect->x);
HXDLIN( 329)					Int _hx_tmp21 = ::Std_obj::_hx_int(firstGrandChild->rect->y);
HXDLIN( 329)					::flixel::graphics::atlas::FlxAtlas_obj::point->setTo(_hx_tmp20,_hx_tmp21);
HXLINE( 330)					 ::openfl::_legacy::geom::Rectangle _hx_tmp22 = firstGrandChildData->get_rect();
HXDLIN( 330)					this->bitmapData->copyPixels(firstGrandChildData,_hx_tmp22,::flixel::graphics::atlas::FlxAtlas_obj::point,null(),null(),null());
            				}
HXLINE( 333)				this->addNodeToAtlasFrames(firstGrandChild);
HXLINE( 334)				this->nodes->set(firstGrandChildKey,firstGrandChild);
            			}
HXLINE( 337)			return firstGrandChild;
            		}
HXLINE( 340)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC7(FlxAtlas_obj,divideNode,return )

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::insertFirstNodeInRoot( ::openfl::_legacy::display::BitmapData data,::String key){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","insertFirstNodeInRoot",0xea82177f,"flixel.graphics.atlas.FlxAtlas.insertFirstNodeInRoot","flixel/graphics/atlas/FlxAtlas.hx",344,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(data,"data")
            	HX_STACK_ARG(key,"key")
HXLINE( 345)		Bool _hx_tmp = hx::IsNull( this->root->left );
HXDLIN( 345)		if (_hx_tmp) {
HXLINE( 347)			Int _hx_tmp1 = data->get_width();
HXDLIN( 347)			HX_VARI( Int,insertWidth) = (_hx_tmp1 + this->border);
HXLINE( 348)			Int _hx_tmp2 = data->get_height();
HXDLIN( 348)			HX_VARI( Int,insertHeight) = (_hx_tmp2 + this->border);
HXLINE( 350)			HX_VARI( Int,rootWidth) = insertWidth;
HXLINE( 351)			HX_VARI( Int,rootHeight) = insertHeight;
HXLINE( 353)			Bool _hx_tmp3 = this->powerOfTwo;
HXDLIN( 353)			if (_hx_tmp3) {
HXLINE( 355)				rootWidth = this->getNextPowerOfTwo(insertWidth);
HXLINE( 356)				rootHeight = this->getNextPowerOfTwo(insertHeight);
            			}
HXLINE( 359)			Bool _hx_tmp4 = (this->minWidth > rootWidth);
HXDLIN( 359)			if (_hx_tmp4) {
HXLINE( 359)				rootWidth = this->minWidth;
            			}
            			else {
HXLINE( 359)				rootWidth = rootWidth;
            			}
HXLINE( 360)			Bool _hx_tmp5 = (this->minHeight > rootHeight);
HXDLIN( 360)			if (_hx_tmp5) {
HXLINE( 360)				rootHeight = this->minHeight;
            			}
            			else {
HXLINE( 360)				rootHeight = rootHeight;
            			}
HXLINE( 362)			Bool _hx_tmp6 = this->powerOfTwo;
HXDLIN( 362)			if (_hx_tmp6) {
HXLINE( 364)				rootWidth = this->getNextPowerOfTwo(rootWidth);
HXLINE( 365)				rootHeight = this->getNextPowerOfTwo(rootHeight);
            			}
HXLINE( 368)			Bool _hx_tmp7;
HXDLIN( 368)			Bool _hx_tmp8;
HXDLIN( 368)			if ((this->maxWidth > (int)0)) {
HXLINE( 368)				_hx_tmp8 = (rootWidth > this->maxWidth);
            			}
            			else {
HXLINE( 368)				_hx_tmp8 = false;
            			}
HXDLIN( 368)			if (!(_hx_tmp8)) {
HXLINE( 368)				if ((this->maxHeight > (int)0)) {
HXLINE( 368)					_hx_tmp7 = (rootHeight > this->maxHeight);
            				}
            				else {
HXLINE( 368)					_hx_tmp7 = false;
            				}
            			}
            			else {
HXLINE( 368)				_hx_tmp7 = true;
            			}
HXDLIN( 368)			if (_hx_tmp7) {
HXLINE( 371)				::String _hx_tmp9 = ((HX_("Can't insert node ",5a,c7,4d,53) + key) + HX_(" with the size of (",b5,20,c2,55));
HXDLIN( 371)				Int _hx_tmp10 = data->get_width();
HXDLIN( 371)				::String _hx_tmp11 = ((_hx_tmp9 + _hx_tmp10) + HX_("; ",85,33,00,00));
HXDLIN( 371)				Int _hx_tmp12 = data->get_height();
HXDLIN( 371)				::String _hx_tmp13 = ((((((((_hx_tmp11 + _hx_tmp12) + HX_(") in atlas ",99,70,14,d3)) + this->name) + HX_(" with the max size of (",b9,b3,66,74)) + this->maxWidth) + HX_("; ",85,33,00,00)) + this->maxHeight) + HX_(") and powerOfTwo: ",d6,69,4d,94));
HXDLIN( 371)				::String _hx_tmp14 = ::Std_obj::string(this->powerOfTwo);
HXDLIN( 371)				HX_STACK_DO_THROW((_hx_tmp13 + _hx_tmp14));
            			}
HXLINE( 376)			this->root->set_width(rootWidth);
HXLINE( 377)			this->root->set_height(rootHeight);
HXLINE( 379)			HX_VARI( Bool,horizontally) = this->needToDivideHorizontally(this->root,insertWidth,insertHeight);
HXLINE( 380)			return this->divideNode(this->root,insertWidth,insertHeight,horizontally,data,key,null());
            		}
HXLINE( 383)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,insertFirstNodeInRoot,return )

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::expand( ::openfl::_legacy::display::BitmapData data,::String key){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","expand",0x67ef7d5b,"flixel.graphics.atlas.FlxAtlas.expand","flixel/graphics/atlas/FlxAtlas.hx",387,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(data,"data")
            	HX_STACK_ARG(key,"key")
HXLINE( 388)		Bool _hx_tmp = hx::IsNull( this->root->right );
HXDLIN( 388)		if (_hx_tmp) {
HXLINE( 390)			Int _hx_tmp1 = data->get_width();
HXDLIN( 390)			HX_VARI( Int,insertWidth) = (_hx_tmp1 + this->border);
HXLINE( 391)			Int _hx_tmp2 = data->get_height();
HXDLIN( 391)			HX_VARI( Int,insertHeight) = (_hx_tmp2 + this->border);
HXLINE( 394)			Int _hx_tmp3 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN( 394)			HX_VARI( Int,addRightWidth) = (_hx_tmp3 + insertWidth);
HXLINE( 395)			Int _hx_tmp4 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN( 395)			Float _hx_tmp5 = ::Math_obj::max(_hx_tmp4,insertHeight);
HXDLIN( 395)			HX_VARI( Int,addRightHeight) = ::Std_obj::_hx_int(_hx_tmp5);
HXLINE( 397)			Int _hx_tmp6 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN( 397)			Float _hx_tmp7 = ::Math_obj::max(_hx_tmp6,insertWidth);
HXDLIN( 397)			HX_VARI( Int,addBottomWidth) = ::Std_obj::_hx_int(_hx_tmp7);
HXLINE( 398)			Int _hx_tmp8 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN( 398)			HX_VARI( Int,addBottomHeight) = (_hx_tmp8 + insertHeight);
HXLINE( 400)			HX_VARI( Int,addRightWidthRotate) = addRightWidth;
HXLINE( 401)			HX_VARI( Int,addRightHeightRotate) = addRightHeight;
HXLINE( 403)			HX_VARI( Int,addBottomWidthRotate) = addBottomWidth;
HXLINE( 404)			HX_VARI( Int,addBottomHeightRotate) = addBottomHeight;
HXLINE( 406)			Bool _hx_tmp9 = this->allowRotation;
HXDLIN( 406)			if (_hx_tmp9) {
HXLINE( 408)				Int _hx_tmp10 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN( 408)				addRightWidthRotate = (_hx_tmp10 + insertHeight);
HXLINE( 409)				Int _hx_tmp11 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN( 409)				Float _hx_tmp12 = ::Math_obj::max(_hx_tmp11,insertWidth);
HXDLIN( 409)				addRightHeightRotate = ::Std_obj::_hx_int(_hx_tmp12);
HXLINE( 411)				Int _hx_tmp13 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN( 411)				Float _hx_tmp14 = ::Math_obj::max(_hx_tmp13,insertHeight);
HXDLIN( 411)				addBottomWidthRotate = ::Std_obj::_hx_int(_hx_tmp14);
HXLINE( 412)				Int _hx_tmp15 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN( 412)				addBottomHeightRotate = (_hx_tmp15 + insertWidth);
            			}
HXLINE( 415)			Bool _hx_tmp16 = this->powerOfTwo;
HXDLIN( 415)			if (_hx_tmp16) {
HXLINE( 417)				addRightWidth = this->getNextPowerOfTwo(addRightWidth);
HXDLIN( 417)				addRightWidthRotate = addRightWidth;
HXLINE( 418)				addRightHeight = this->getNextPowerOfTwo(addRightHeight);
HXDLIN( 418)				addRightHeightRotate = addRightHeight;
HXLINE( 419)				addBottomWidth = this->getNextPowerOfTwo(addBottomWidth);
HXDLIN( 419)				addBottomWidthRotate = addBottomWidth;
HXLINE( 420)				addBottomHeight = this->getNextPowerOfTwo(addBottomHeight);
HXDLIN( 420)				addBottomHeightRotate = addBottomHeight;
HXLINE( 422)				Bool _hx_tmp17 = this->allowRotation;
HXDLIN( 422)				if (_hx_tmp17) {
HXLINE( 424)					addRightWidthRotate = this->getNextPowerOfTwo(addRightWidthRotate);
HXLINE( 425)					addRightHeightRotate = this->getNextPowerOfTwo(addRightHeightRotate);
HXLINE( 426)					addBottomWidthRotate = this->getNextPowerOfTwo(addBottomWidthRotate);
HXLINE( 427)					addBottomHeightRotate = this->getNextPowerOfTwo(addBottomHeightRotate);
            				}
            			}
HXLINE( 432)			HX_VARI( Bool,canExpandRight) = true;
HXLINE( 433)			HX_VARI( Bool,canExpandBottom) = true;
HXLINE( 435)			HX_VARI( Bool,canExpandRightRotate) = this->allowRotation;
HXLINE( 436)			HX_VARI( Bool,canExpandBottomRotate) = this->allowRotation;
HXLINE( 438)			Bool _hx_tmp18;
HXDLIN( 438)			Bool _hx_tmp19;
HXDLIN( 438)			if ((this->maxWidth > (int)0)) {
HXLINE( 438)				_hx_tmp19 = (addRightWidth > this->maxWidth);
            			}
            			else {
HXLINE( 438)				_hx_tmp19 = false;
            			}
HXDLIN( 438)			if (!(_hx_tmp19)) {
HXLINE( 438)				if ((this->maxHeight > (int)0)) {
HXLINE( 438)					_hx_tmp18 = (addRightHeight > this->maxHeight);
            				}
            				else {
HXLINE( 438)					_hx_tmp18 = false;
            				}
            			}
            			else {
HXLINE( 438)				_hx_tmp18 = true;
            			}
HXDLIN( 438)			if (_hx_tmp18) {
HXLINE( 439)				canExpandRight = false;
            			}
HXLINE( 441)			Bool _hx_tmp20;
HXDLIN( 441)			Bool _hx_tmp21;
HXDLIN( 441)			if ((this->maxWidth > (int)0)) {
HXLINE( 441)				_hx_tmp21 = (addBottomWidth > this->maxWidth);
            			}
            			else {
HXLINE( 441)				_hx_tmp21 = false;
            			}
HXDLIN( 441)			if (!(_hx_tmp21)) {
HXLINE( 441)				if ((this->maxHeight > (int)0)) {
HXLINE( 441)					_hx_tmp20 = (addBottomHeight > this->maxHeight);
            				}
            				else {
HXLINE( 441)					_hx_tmp20 = false;
            				}
            			}
            			else {
HXLINE( 441)				_hx_tmp20 = true;
            			}
HXDLIN( 441)			if (_hx_tmp20) {
HXLINE( 442)				canExpandBottom = false;
            			}
HXLINE( 444)			Bool _hx_tmp22;
HXDLIN( 444)			Bool _hx_tmp23;
HXDLIN( 444)			if ((this->maxWidth > (int)0)) {
HXLINE( 444)				_hx_tmp23 = (addRightWidthRotate > this->maxWidth);
            			}
            			else {
HXLINE( 444)				_hx_tmp23 = false;
            			}
HXDLIN( 444)			if (!(_hx_tmp23)) {
HXLINE( 444)				if ((this->maxHeight > (int)0)) {
HXLINE( 444)					_hx_tmp22 = (addRightHeightRotate > this->maxHeight);
            				}
            				else {
HXLINE( 444)					_hx_tmp22 = false;
            				}
            			}
            			else {
HXLINE( 444)				_hx_tmp22 = true;
            			}
HXDLIN( 444)			if (_hx_tmp22) {
HXLINE( 445)				canExpandRightRotate = false;
            			}
HXLINE( 447)			Bool _hx_tmp24;
HXDLIN( 447)			Bool _hx_tmp25;
HXDLIN( 447)			if ((this->maxWidth > (int)0)) {
HXLINE( 447)				_hx_tmp25 = (addBottomWidthRotate > this->maxWidth);
            			}
            			else {
HXLINE( 447)				_hx_tmp25 = false;
            			}
HXDLIN( 447)			if (!(_hx_tmp25)) {
HXLINE( 447)				if ((this->maxHeight > (int)0)) {
HXLINE( 447)					_hx_tmp24 = (addBottomHeightRotate > this->maxHeight);
            				}
            				else {
HXLINE( 447)					_hx_tmp24 = false;
            				}
            			}
            			else {
HXLINE( 447)				_hx_tmp24 = true;
            			}
HXDLIN( 447)			if (_hx_tmp24) {
HXLINE( 448)				canExpandBottomRotate = false;
            			}
HXLINE( 450)			Bool _hx_tmp26;
HXDLIN( 450)			Bool _hx_tmp27;
HXDLIN( 450)			Bool _hx_tmp28;
HXDLIN( 450)			if (!(canExpandRight)) {
HXLINE( 450)				_hx_tmp28 = !(canExpandBottom);
            			}
            			else {
HXLINE( 450)				_hx_tmp28 = false;
            			}
HXDLIN( 450)			if (_hx_tmp28) {
HXLINE( 450)				_hx_tmp27 = !(canExpandRightRotate);
            			}
            			else {
HXLINE( 450)				_hx_tmp27 = false;
            			}
HXDLIN( 450)			if (_hx_tmp27) {
HXLINE( 450)				_hx_tmp26 = !(canExpandBottomRotate);
            			}
            			else {
HXLINE( 450)				_hx_tmp26 = false;
            			}
HXDLIN( 450)			if (_hx_tmp26) {
HXLINE( 453)				::String _hx_tmp29 = ((HX_("Can't insert node ",5a,c7,4d,53) + key) + HX_(" with the size of (",b5,20,c2,55));
HXDLIN( 453)				Int _hx_tmp30 = data->get_width();
HXDLIN( 453)				::String _hx_tmp31 = ((_hx_tmp29 + _hx_tmp30) + HX_("; ",85,33,00,00));
HXDLIN( 453)				Int _hx_tmp32 = data->get_height();
HXDLIN( 453)				::String _hx_tmp33 = ((((((((_hx_tmp31 + _hx_tmp32) + HX_(") in atlas ",99,70,14,d3)) + this->name) + HX_(" with the max size of (",b9,b3,66,74)) + this->maxWidth) + HX_("; ",85,33,00,00)) + this->maxHeight) + HX_(") and powerOfTwo: ",d6,69,4d,94));
HXDLIN( 453)				::String _hx_tmp34 = ::Std_obj::string(this->powerOfTwo);
HXDLIN( 453)				HX_STACK_DO_THROW((_hx_tmp33 + _hx_tmp34));
            			}
HXLINE( 460)			HX_VARI( Int,addRightArea) = (addRightWidth * addRightHeight);
HXLINE( 461)			HX_VARI( Int,addBottomArea) = (addBottomWidth * addBottomHeight);
HXLINE( 463)			HX_VARI( Int,addRightAreaRotate) = (addRightWidthRotate * addRightHeightRotate);
HXLINE( 464)			HX_VARI( Int,addBottomAreaRotate) = (addBottomWidthRotate * addBottomHeightRotate);
HXLINE( 466)			HX_VARI( Bool,rotateRight) = false;
HXLINE( 467)			HX_VARI( Bool,rotateBottom) = false;
HXLINE( 470)			Bool _hx_tmp35;
HXDLIN( 470)			Bool _hx_tmp36;
HXDLIN( 470)			Bool _hx_tmp37;
HXDLIN( 470)			if (canExpandRight) {
HXLINE( 470)				_hx_tmp37 = canExpandRightRotate;
            			}
            			else {
HXLINE( 470)				_hx_tmp37 = false;
            			}
HXDLIN( 470)			if (_hx_tmp37) {
HXLINE( 470)				_hx_tmp36 = (addRightArea > addRightAreaRotate);
            			}
            			else {
HXLINE( 470)				_hx_tmp36 = false;
            			}
HXDLIN( 470)			if (!(_hx_tmp36)) {
HXLINE( 470)				if (!(canExpandRight)) {
HXLINE( 470)					_hx_tmp35 = canExpandRightRotate;
            				}
            				else {
HXLINE( 470)					_hx_tmp35 = false;
            				}
            			}
            			else {
HXLINE( 470)				_hx_tmp35 = true;
            			}
HXDLIN( 470)			if (_hx_tmp35) {
HXLINE( 472)				addRightArea = addBottomAreaRotate;
HXLINE( 473)				addRightWidth = addRightWidthRotate;
HXLINE( 474)				addRightHeight = addRightHeightRotate;
HXLINE( 475)				canExpandRight = true;
HXLINE( 476)				rotateRight = true;
            			}
HXLINE( 479)			Bool _hx_tmp38;
HXDLIN( 479)			Bool _hx_tmp39;
HXDLIN( 479)			Bool _hx_tmp40;
HXDLIN( 479)			if (canExpandBottom) {
HXLINE( 479)				_hx_tmp40 = canExpandBottomRotate;
            			}
            			else {
HXLINE( 479)				_hx_tmp40 = false;
            			}
HXDLIN( 479)			if (_hx_tmp40) {
HXLINE( 479)				_hx_tmp39 = (addBottomArea > addBottomAreaRotate);
            			}
            			else {
HXLINE( 479)				_hx_tmp39 = false;
            			}
HXDLIN( 479)			if (!(_hx_tmp39)) {
HXLINE( 479)				if (!(canExpandBottom)) {
HXLINE( 479)					_hx_tmp38 = canExpandBottomRotate;
            				}
            				else {
HXLINE( 479)					_hx_tmp38 = false;
            				}
            			}
            			else {
HXLINE( 479)				_hx_tmp38 = true;
            			}
HXDLIN( 479)			if (_hx_tmp38) {
HXLINE( 481)				addBottomArea = addBottomAreaRotate;
HXLINE( 482)				addBottomWidth = addBottomWidthRotate;
HXLINE( 483)				addBottomHeight = addBottomHeightRotate;
HXLINE( 484)				canExpandBottom = true;
HXLINE( 485)				rotateBottom = true;
            			}
HXLINE( 488)			Bool _hx_tmp41;
HXDLIN( 488)			if (!(canExpandRight)) {
HXLINE( 488)				_hx_tmp41 = canExpandBottom;
            			}
            			else {
HXLINE( 488)				_hx_tmp41 = false;
            			}
HXDLIN( 488)			if (_hx_tmp41) {
HXLINE( 490)				addRightArea = (addBottomArea + (int)1);
            			}
            			else {
HXLINE( 493)				Bool _hx_tmp42;
HXDLIN( 493)				if (canExpandRight) {
HXLINE( 493)					_hx_tmp42 = !(canExpandBottom);
            				}
            				else {
HXLINE( 493)					_hx_tmp42 = false;
            				}
HXDLIN( 493)				if (_hx_tmp42) {
HXLINE( 495)					addBottomArea = (addRightArea + (int)1);
            				}
            			}
HXLINE( 499)			HX_VARI(  ::flixel::graphics::atlas::FlxNode,dataNode) = null();
HXLINE( 500)			HX_VARI(  ::flixel::graphics::atlas::FlxNode,temp) = this->root;
HXLINE( 501)			HX_VARI( Int,insertNodeWidth) = insertWidth;
HXLINE( 502)			HX_VARI( Int,insertNodeHeight) = insertHeight;
HXLINE( 505)			if ((addBottomArea >= addRightArea)) {
HXLINE( 507)				if (rotateRight) {
HXLINE( 509)					insertNodeWidth = insertHeight;
HXLINE( 510)					insertNodeHeight = insertWidth;
            				}
HXLINE( 513)				Int _hx_tmp43 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN( 513)				Int _hx_tmp44 = (_hx_tmp43 + insertNodeWidth);
HXDLIN( 513)				Int _hx_tmp45 = ::Std_obj::_hx_int(temp->rect->height);
HXDLIN( 513)				Float _hx_tmp46 = ::Math_obj::max(_hx_tmp45,insertNodeHeight);
HXDLIN( 513)				this->expandRoot(_hx_tmp44,_hx_tmp46,true,null());
HXLINE( 514)				dataNode = this->divideNode(this->root->right,insertNodeWidth,insertNodeHeight,true,data,key,rotateRight);
HXLINE( 515)				this->expandRoot(addRightWidth,addRightHeight,false,true);
            			}
            			else {
HXLINE( 519)				if (rotateBottom) {
HXLINE( 521)					insertNodeWidth = insertHeight;
HXLINE( 522)					insertNodeHeight = insertWidth;
            				}
HXLINE( 525)				Int _hx_tmp47 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN( 525)				Float _hx_tmp48 = ::Math_obj::max(_hx_tmp47,insertNodeWidth);
HXDLIN( 525)				Int _hx_tmp49 = ::Std_obj::_hx_int(temp->rect->height);
HXDLIN( 525)				this->expandRoot(_hx_tmp48,(_hx_tmp49 + insertNodeHeight),false,null());
HXLINE( 526)				dataNode = this->divideNode(this->root->right,insertNodeWidth,insertNodeHeight,true,data,key,rotateBottom);
HXLINE( 527)				this->expandRoot(addBottomWidth,addBottomHeight,false,true);
            			}
HXLINE( 530)			return dataNode;
            		}
HXLINE( 533)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,expand,return )

void FlxAtlas_obj::expandRoot(Float newWidth,Float newHeight,Bool divideHorizontally,hx::Null< Bool >  __o_decideHowToDivide){
Bool decideHowToDivide = __o_decideHowToDivide.Default(false);
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","expandRoot",0x3df0e11d,"flixel.graphics.atlas.FlxAtlas.expandRoot","flixel/graphics/atlas/FlxAtlas.hx",538,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(newWidth,"newWidth")
            	HX_STACK_ARG(newHeight,"newHeight")
            	HX_STACK_ARG(divideHorizontally,"divideHorizontally")
            	HX_STACK_ARG(decideHowToDivide,"decideHowToDivide")
HXLINE( 538)		Bool _hx_tmp;
HXDLIN( 538)		Int _hx_tmp1 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN( 538)		if (!((newWidth > _hx_tmp1))) {
HXLINE( 538)			Int _hx_tmp2 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN( 538)			_hx_tmp = (newHeight > _hx_tmp2);
            		}
            		else {
HXLINE( 538)			_hx_tmp = true;
            		}
HXDLIN( 538)		if (_hx_tmp) {
HXLINE( 540)			HX_VARI(  ::flixel::graphics::atlas::FlxNode,temp) = this->root;
HXLINE( 541)			HX_VARI(  ::flixel::math::FlxRect,_this) = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 541)			_this->x = (int)0;
HXDLIN( 541)			_this->y = (int)0;
HXDLIN( 541)			_this->width = newWidth;
HXDLIN( 541)			_this->height = newHeight;
HXDLIN( 541)			_this->_inPool = false;
HXDLIN( 541)			this->root =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE( 543)			if (decideHowToDivide) {
HXLINE( 543)				Int _hx_tmp3 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN( 543)				Int _hx_tmp4 = ::Std_obj::_hx_int(temp->rect->height);
HXDLIN( 543)				divideHorizontally = this->needToDivideHorizontally(this->root,_hx_tmp3,_hx_tmp4);
            			}
            			else {
HXLINE( 543)				divideHorizontally = divideHorizontally;
            			}
HXLINE( 545)			Int _hx_tmp5 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN( 545)			Int _hx_tmp6 = ::Std_obj::_hx_int(temp->rect->height);
HXDLIN( 545)			this->divideNode(this->root,_hx_tmp5,_hx_tmp6,divideHorizontally,null(),null(),null());
HXLINE( 546)			this->root->left->left = temp;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxAtlas_obj,expandRoot,(void))

void FlxAtlas_obj::expandBitmapData(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","expandBitmapData",0xdc8f96f4,"flixel.graphics.atlas.FlxAtlas.expandBitmapData","flixel/graphics/atlas/FlxAtlas.hx",551,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 552)		Bool _hx_tmp;
HXDLIN( 552)		Bool _hx_tmp1;
HXDLIN( 552)		Bool _hx_tmp2 = hx::IsNotNull( this->bitmapData );
HXDLIN( 552)		if (_hx_tmp2) {
HXLINE( 552)			Int _hx_tmp3 = this->bitmapData->get_width();
HXDLIN( 552)			Int _hx_tmp4 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN( 552)			_hx_tmp1 = (_hx_tmp3 == _hx_tmp4);
            		}
            		else {
HXLINE( 552)			_hx_tmp1 = false;
            		}
HXDLIN( 552)		if (_hx_tmp1) {
HXLINE( 552)			Int _hx_tmp5 = this->bitmapData->get_height();
HXDLIN( 552)			Int _hx_tmp6 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN( 552)			_hx_tmp = (_hx_tmp5 == _hx_tmp6);
            		}
            		else {
HXLINE( 552)			_hx_tmp = false;
            		}
HXDLIN( 552)		if (_hx_tmp) {
HXLINE( 554)			return;
            		}
HXLINE( 557)		Int _hx_tmp7 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN( 557)		Int _hx_tmp8 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN( 557)		HX_VARI(  ::openfl::_legacy::display::BitmapData,newBitmapData) =  ::openfl::_legacy::display::BitmapData_obj::__new(_hx_tmp7,_hx_tmp8,true,(int)0,null());
HXLINE( 558)		Bool _hx_tmp9 = hx::IsNotNull( this->bitmapData );
HXDLIN( 558)		if (_hx_tmp9) {
HXLINE( 560)			::flixel::graphics::atlas::FlxAtlas_obj::point->setTo((int)0,(int)0);
HXLINE( 561)			 ::openfl::_legacy::geom::Rectangle _hx_tmp10 = this->bitmapData->get_rect();
HXDLIN( 561)			newBitmapData->copyPixels(this->bitmapData,_hx_tmp10,::flixel::graphics::atlas::FlxAtlas_obj::point,null(),null(),null());
            		}
HXLINE( 564)		 ::openfl::_legacy::display::BitmapData _hx_tmp11 = ::flixel::util::FlxDestroyUtil_obj::dispose(this->bitmapData);
HXDLIN( 564)		this->set_bitmapData(_hx_tmp11);
HXLINE( 565)		this->set_bitmapData(newBitmapData);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,expandBitmapData,(void))

Int FlxAtlas_obj::getNextPowerOfTwo(Float number){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","getNextPowerOfTwo",0x3bc20318,"flixel.graphics.atlas.FlxAtlas.getNextPowerOfTwo","flixel/graphics/atlas/FlxAtlas.hx",569,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(number,"number")
HXLINE( 570)		HX_VARI( Int,n) = ::Std_obj::_hx_int(number);
HXLINE( 571)		Bool _hx_tmp;
HXDLIN( 571)		if ((n > (int)0)) {
HXLINE( 571)			_hx_tmp = (((int)n & (int)(n - (int)1)) == (int)0);
            		}
            		else {
HXLINE( 571)			_hx_tmp = false;
            		}
HXDLIN( 571)		if (_hx_tmp) {
HXLINE( 573)			return n;
            		}
HXLINE( 576)		HX_VARI( Int,result) = (int)1;
HXLINE( 577)		while((result < n)){
HXLINE( 577)			hx::ShlEq(result,(int)1);
            		}
HXLINE( 578)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,getNextPowerOfTwo,return )

 ::flixel::graphics::frames::FlxTileFrames FlxAtlas_obj::addNodeWithSpacesAndBorders( ::Dynamic Graphic,::String Key, ::flixel::math::FlxPoint tileSize, ::flixel::math::FlxPoint tileSpacing, ::flixel::math::FlxPoint tileBorder, ::flixel::math::FlxRect region){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","addNodeWithSpacesAndBorders",0x375b9d25,"flixel.graphics.atlas.FlxAtlas.addNodeWithSpacesAndBorders","flixel/graphics/atlas/FlxAtlas.hx",594,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(Graphic,"Graphic")
            	HX_STACK_ARG(Key,"Key")
            	HX_STACK_ARG(tileSize,"tileSize")
            	HX_STACK_ARG(tileSpacing,"tileSpacing")
            	HX_STACK_ARG(tileBorder,"tileBorder")
            	HX_STACK_ARG(region,"region")
HXLINE( 595)		HX_VARI( ::String,key) = ::flixel::_hx_system::FlxAssets_obj::resolveKey(Graphic,Key);
HXLINE( 597)		Bool _hx_tmp = hx::IsNull( key );
HXDLIN( 597)		if (_hx_tmp) {
HXLINE( 600)			HX_STACK_DO_THROW(HX_("addNodeWithSpacings can't find the key for specified bitmapdata. Please provide not null value as a Key argument.",68,27,93,19));
            		}
HXLINE( 605)		key = ::flixel::FlxG_obj::bitmap->getKeyWithSpacesAndBorders(key,tileSize,tileSpacing,tileBorder,region);
HXLINE( 607)		Bool _hx_tmp1 = this->hasNodeWithName(key);
HXDLIN( 607)		if (_hx_tmp1) {
HXLINE( 608)			return this->nodes->get(key).StaticCast<  ::flixel::graphics::atlas::FlxNode >()->getTileFrames(tileSize,tileSpacing,tileBorder);
            		}
HXLINE( 610)		HX_VARI(  ::openfl::_legacy::display::BitmapData,data) = ::flixel::_hx_system::FlxAssets_obj::resolveBitmapData(Graphic);
HXLINE( 612)		Bool _hx_tmp2 = hx::IsNull( data );
HXDLIN( 612)		if (_hx_tmp2) {
HXLINE( 615)			HX_STACK_DO_THROW(((HX_("addNodeWithSpacings can't find bitmapdata with specified key: ",25,03,32,92) + Graphic) + HX_(". Please provide valid value.",84,e6,88,32)));
            		}
HXLINE( 620)		HX_VARI(  ::openfl::_legacy::display::BitmapData,nodeData) = ::flixel::util::FlxBitmapDataUtil_obj::addSpacesAndBorders(data,tileSize,tileSpacing,tileBorder,region);
HXLINE( 621)		HX_VARI(  ::flixel::graphics::atlas::FlxNode,node) = this->addNode(nodeData,key);
HXLINE( 623)		Bool _hx_tmp3 = hx::IsNull( node );
HXDLIN( 623)		if (_hx_tmp3) {
HXLINE( 626)			HX_STACK_DO_THROW(((HX_("addNodeWithSpacings can't insert provided image: ",a1,49,3a,35) + Graphic) + HX_(") in atlas. It's probably too big.",a7,39,69,92)));
            		}
HXLINE( 631)		Bool _hx_tmp4 = hx::IsNotNull( tileBorder );
HXDLIN( 631)		if (_hx_tmp4) {
HXLINE( 633)			Float X = ((int)2 * tileBorder->x);
HXDLIN( 633)			Float Y = ((int)2 * tileBorder->y);
HXDLIN( 633)			{
HXLINE( 633)				Float _hx_tmp5 = (tileSize->x + X);
HXDLIN( 633)				tileSize->set_x(_hx_tmp5);
            			}
HXDLIN( 633)			{
HXLINE( 633)				Float _hx_tmp6 = (tileSize->y + Y);
HXDLIN( 633)				tileSize->set_y(_hx_tmp6);
            			}
            		}
HXLINE( 636)		return node->getTileFrames(tileSize,tileSpacing,tileBorder);
            	}


HX_DEFINE_DYNAMIC_FUNC6(FlxAtlas_obj,addNodeWithSpacesAndBorders,return )

 ::flixel::graphics::frames::FlxAtlasFrames FlxAtlas_obj::getAtlasFrames(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","getAtlasFrames",0xe2ec465c,"flixel.graphics.atlas.FlxAtlas.getAtlasFrames","flixel/graphics/atlas/FlxAtlas.hx",645,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 646)		HX_VARI(  ::flixel::graphics::FlxGraphic,graph) = this->get_graphic();
HXLINE( 648)		HX_VARI(  ::flixel::graphics::frames::FlxAtlasFrames,atlasFrames) = graph->get_atlasFrames();
HXLINE( 649)		 ::flixel::graphics::frames::FlxAtlasFrames _hx_tmp = graph->get_atlasFrames();
HXDLIN( 649)		Bool _hx_tmp1 = hx::IsNull( _hx_tmp );
HXDLIN( 649)		if (_hx_tmp1) {
HXLINE( 651)			atlasFrames =  ::flixel::graphics::frames::FlxAtlasFrames_obj::__new(graph,null());
            		}
HXLINE( 654)		{
HXLINE( 654)			HX_VARI(  ::Dynamic,tmp) = this->nodes->iterator();
HXDLIN( 654)			while(true){
HXLINE( 654)				Bool _hx_tmp2 = !(( (Bool)( ::Dynamic(tmp->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic))()) ));
HXDLIN( 654)				if (_hx_tmp2) {
HXLINE( 654)					goto _hx_goto_1;
            				}
HXDLIN( 654)				HX_VARI(  ::flixel::graphics::atlas::FlxNode,node) = ( ( ::flixel::graphics::atlas::FlxNode)( ::Dynamic(tmp->__Field(HX_("next",f3,84,02,49),hx::paccDynamic))()) );
HXLINE( 655)				this->addNodeToAtlasFrames(node);
            			}
            			_hx_goto_1:;
            		}
HXLINE( 657)		return atlasFrames;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,getAtlasFrames,return )

void FlxAtlas_obj::addNodeToAtlasFrames( ::flixel::graphics::atlas::FlxNode node){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","addNodeToAtlasFrames",0x19696d94,"flixel.graphics.atlas.FlxAtlas.addNodeToAtlasFrames","flixel/graphics/atlas/FlxAtlas.hx",661,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(node,"node")
HXLINE( 662)		Bool _hx_tmp;
HXDLIN( 662)		Bool _hx_tmp1;
HXDLIN( 662)		Bool _hx_tmp2 = hx::IsNotNull( this->_graphic );
HXDLIN( 662)		if (_hx_tmp2) {
HXLINE( 662)			 ::flixel::graphics::frames::FlxAtlasFrames _hx_tmp3 = this->_graphic->get_atlasFrames();
HXDLIN( 662)			_hx_tmp1 = hx::IsNull( _hx_tmp3 );
            		}
            		else {
HXLINE( 662)			_hx_tmp1 = true;
            		}
HXDLIN( 662)		if (!(_hx_tmp1)) {
HXLINE( 662)			_hx_tmp = hx::IsNull( node );
            		}
            		else {
HXLINE( 662)			_hx_tmp = true;
            		}
HXDLIN( 662)		if (_hx_tmp) {
HXLINE( 663)			return;
            		}
HXLINE( 665)		HX_VARI(  ::flixel::graphics::frames::FlxAtlasFrames,atlasFrames) = this->_graphic->get_atlasFrames();
HXLINE( 667)		Bool _hx_tmp4;
HXDLIN( 667)		Bool _hx_tmp5 = node->filled;
HXDLIN( 667)		if (_hx_tmp5) {
HXLINE( 667)			_hx_tmp4 = !(atlasFrames->framesHash->exists(node->key));
            		}
            		else {
HXLINE( 667)			_hx_tmp4 = false;
            		}
HXDLIN( 667)		if (_hx_tmp4) {
HXLINE( 669)			Float X = ::Std_obj::_hx_int(node->rect->x);
HXDLIN( 669)			Float Y = ::Std_obj::_hx_int(node->rect->y);
HXDLIN( 669)			Int _hx_tmp6 = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 669)			Float Width = (_hx_tmp6 - this->border);
HXDLIN( 669)			Int _hx_tmp7 = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 669)			Float Height = (_hx_tmp7 - this->border);
HXDLIN( 669)			HX_VARI(  ::flixel::math::FlxRect,_this) = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 669)			_this->x = X;
HXDLIN( 669)			_this->y = Y;
HXDLIN( 669)			_this->width = Width;
HXDLIN( 669)			_this->height = Height;
HXDLIN( 669)			_this->_inPool = false;
HXLINE( 670)			HX_VAR(  ::flixel::math::FlxPoint,sourceSize);
HXDLIN( 670)			Bool _hx_tmp8 = node->rotated;
HXDLIN( 670)			if (_hx_tmp8) {
HXLINE( 670)				Int _hx_tmp9 = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 670)				Float X1 = (_hx_tmp9 - this->border);
HXDLIN( 670)				Int _hx_tmp10 = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 670)				Float Y1 = (_hx_tmp10 - this->border);
HXDLIN( 670)				HX_VARI(  ::flixel::math::FlxPoint,point) = ::flixel::math::FlxPoint_obj::_pool->get()->set(X1,Y1);
HXDLIN( 670)				point->_inPool = false;
HXDLIN( 670)				sourceSize = point;
            			}
            			else {
HXLINE( 670)				Int _hx_tmp11 = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 670)				Float X2 = (_hx_tmp11 - this->border);
HXDLIN( 670)				Int _hx_tmp12 = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 670)				Float Y2 = (_hx_tmp12 - this->border);
HXDLIN( 670)				HX_VARI_NAME(  ::flixel::math::FlxPoint,point1,"point") = ::flixel::math::FlxPoint_obj::_pool->get()->set(X2,Y2);
HXDLIN( 670)				point1->_inPool = false;
HXDLIN( 670)				sourceSize = point1;
            			}
HXLINE( 671)			HX_VARI_NAME(  ::flixel::math::FlxPoint,point2,"point") = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN( 671)			point2->_inPool = false;
HXLINE( 672)			HX_VAR( Int,angle);
HXDLIN( 672)			if (node->rotated) {
HXLINE( 672)				angle = (int)-90;
            			}
            			else {
HXLINE( 672)				angle = (int)0;
            			}
HXLINE( 673)			atlasFrames->addAtlasFrame(_this,sourceSize,point2,node->key,angle,null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,addNodeToAtlasFrames,(void))

Bool FlxAtlas_obj::hasNodeWithName(::String nodeName){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","hasNodeWithName",0x3a185aec,"flixel.graphics.atlas.FlxAtlas.hasNodeWithName","flixel/graphics/atlas/FlxAtlas.hx",684,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(nodeName,"nodeName")
HXLINE( 684)		return this->nodes->exists(nodeName);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,hasNodeWithName,return )

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::getNode(::String key){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","getNode",0x850d4b97,"flixel.graphics.atlas.FlxAtlas.getNode","flixel/graphics/atlas/FlxAtlas.hx",694,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(key,"key")
HXLINE( 694)		return this->nodes->get(key).StaticCast<  ::flixel::graphics::atlas::FlxNode >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,getNode,return )

 ::flixel::graphics::atlas::FlxAtlas FlxAtlas_obj::addNodes(::Array< ::Dynamic> bitmaps,::Array< ::String > keys){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","addNodes",0x001aef91,"flixel.graphics.atlas.FlxAtlas.addNodes","flixel/graphics/atlas/FlxAtlas.hx",705,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(bitmaps,"bitmaps")
            	HX_STACK_ARG(keys,"keys")
HXLINE( 706)		HX_VARI( Int,numKeys) = keys->length;
HXLINE( 707)		HX_VARI( Int,numBitmaps) = bitmaps->length;
HXLINE( 709)		if ((numBitmaps != numKeys)) {
HXLINE( 712)			HX_STACK_DO_THROW(((((HX_("The number of bitmaps (",cb,e8,a2,a6) + numBitmaps) + HX_(") should be equal to number of keys (",a0,90,37,97)) + numKeys) + HX_(")",29,00,00,00)));
            		}
HXLINE( 717)		this->_tempStorage = ::Array_obj< ::Dynamic>::__new();
HXLINE( 718)		{
HXLINE( 718)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 718)			while((_g1 < numBitmaps)){
HXLINE( 718)				HX_VARI( Int,i) = _g1++;
HXLINE( 720)				 ::openfl::_legacy::display::BitmapData _hx_tmp = bitmaps->__get(i).StaticCast<  ::openfl::_legacy::display::BitmapData >();
HXDLIN( 720)				::String _hx_tmp1 = keys->__get(i);
HXDLIN( 720)				this->_tempStorage->push( ::Dynamic(hx::Anon_obj::Create(2)
            					->setFixed(0,HX_("bmd",39,bc,4a,00),_hx_tmp)
            					->setFixed(1,HX_("keyStr",52,64,e2,3f),_hx_tmp1)));
            			}
            		}
HXLINE( 723)		this->addFromAtlasObjects(this->_tempStorage);
HXLINE( 724)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,addNodes,return )

void FlxAtlas_obj::addFromAtlasObjects(::Array< ::Dynamic> objects){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","addFromAtlasObjects",0xc364fff3,"flixel.graphics.atlas.FlxAtlas.addFromAtlasObjects","flixel/graphics/atlas/FlxAtlas.hx",728,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(objects,"objects")
HXLINE( 729)		objects->sort(this->bitmapSorter_dyn());
HXLINE( 730)		HX_VARI( Int,numBitmaps) = objects->length;
HXLINE( 732)		{
HXLINE( 732)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 732)			while((_g1 < numBitmaps)){
HXLINE( 732)				HX_VARI( Int,i) = _g1++;
HXLINE( 734)				this->addNode( ::Dynamic(objects->__get(i)->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)), ::Dynamic(objects->__get(i)->__Field(HX_("keyStr",52,64,e2,3f),hx::paccDynamic)));
            			}
            		}
HXLINE( 737)		this->_tempStorage = null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,addFromAtlasObjects,(void))

Int FlxAtlas_obj::bitmapSorter( ::Dynamic obj1, ::Dynamic obj2){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","bitmapSorter",0x4abe7a5b,"flixel.graphics.atlas.FlxAtlas.bitmapSorter","flixel/graphics/atlas/FlxAtlas.hx",744,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(obj1,"obj1")
            	HX_STACK_ARG(obj2,"obj2")
HXLINE( 745)		Bool _hx_tmp = this->allowRotation;
HXDLIN( 745)		if (_hx_tmp) {
HXLINE( 747)			Int _hx_tmp1 = ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 747)			Int _hx_tmp2 = ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_height();
HXDLIN( 747)			HX_VARI( Int,area1) = (_hx_tmp1 * _hx_tmp2);
HXLINE( 748)			Int _hx_tmp3 = ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 748)			Int _hx_tmp4 = ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_height();
HXLINE( 749)			return ((_hx_tmp3 * _hx_tmp4) - area1);
            		}
HXLINE( 752)		Int _hx_tmp5 = ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 752)		Int _hx_tmp6 = ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 752)		if ((_hx_tmp5 == _hx_tmp6)) {
HXLINE( 754)			Int _hx_tmp7 = ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_height();
HXDLIN( 754)			Int _hx_tmp8 = ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_height();
HXDLIN( 754)			return (_hx_tmp7 - _hx_tmp8);
            		}
HXLINE( 757)		Int _hx_tmp9 = ( ( ::openfl::_legacy::display::BitmapData)(obj2->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 757)		Int _hx_tmp10 = ( ( ::openfl::_legacy::display::BitmapData)(obj1->__Field(HX_("bmd",39,bc,4a,00),hx::paccDynamic)) )->get_width();
HXDLIN( 757)		return (_hx_tmp9 - _hx_tmp10);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,bitmapSorter,return )

 ::flixel::graphics::atlas::FlxAtlas FlxAtlas_obj::createQueue(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","createQueue",0x315e3254,"flixel.graphics.atlas.FlxAtlas.createQueue","flixel/graphics/atlas/FlxAtlas.hx",768,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 769)		this->_tempStorage = ::Array_obj< ::Dynamic>::__new();
HXLINE( 770)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,createQueue,return )

 ::flixel::graphics::atlas::FlxAtlas FlxAtlas_obj::addToQueue( ::openfl::_legacy::display::BitmapData data,::String key){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","addToQueue",0x83cfa976,"flixel.graphics.atlas.FlxAtlas.addToQueue","flixel/graphics/atlas/FlxAtlas.hx",779,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(data,"data")
            	HX_STACK_ARG(key,"key")
HXLINE( 780)		Bool _hx_tmp = hx::IsNull( this->_tempStorage );
HXDLIN( 780)		if (_hx_tmp) {
HXLINE( 782)			this->_tempStorage = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 785)		this->_tempStorage->push( ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("bmd",39,bc,4a,00),data)
            			->setFixed(1,HX_("keyStr",52,64,e2,3f),key)));
HXLINE( 786)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,addToQueue,return )

 ::flixel::graphics::atlas::FlxAtlas FlxAtlas_obj::generateFromQueue(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","generateFromQueue",0x8e4a2871,"flixel.graphics.atlas.FlxAtlas.generateFromQueue","flixel/graphics/atlas/FlxAtlas.hx",793,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 794)		Bool _hx_tmp = hx::IsNotNull( this->_tempStorage );
HXDLIN( 794)		if (_hx_tmp) {
HXLINE( 796)			this->addFromAtlasObjects(this->_tempStorage);
            		}
HXLINE( 799)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,generateFromQueue,return )

void FlxAtlas_obj::onClear( ::flixel::FlxState _){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","onClear",0x4819a1cd,"flixel.graphics.atlas.FlxAtlas.onClear","flixel/graphics/atlas/FlxAtlas.hx",804,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(_,"_")
HXLINE( 804)		Bool _hx_tmp;
HXDLIN( 804)		Bool _hx_tmp1 = !(!(this->persist));
HXDLIN( 804)		if (_hx_tmp1) {
HXLINE( 804)			Bool _hx_tmp2 = hx::IsNotNull( this->_graphic );
HXDLIN( 804)			if (_hx_tmp2) {
HXLINE( 804)				Int _hx_tmp3 = this->_graphic->get_useCount();
HXDLIN( 804)				_hx_tmp = (_hx_tmp3 <= (int)0);
            			}
            			else {
HXLINE( 804)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE( 804)			_hx_tmp = true;
            		}
HXDLIN( 804)		if (_hx_tmp) {
HXLINE( 806)			this->destroy();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,onClear,(void))

void FlxAtlas_obj::destroy(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","destroy",0x8e06bed9,"flixel.graphics.atlas.FlxAtlas.destroy","flixel/graphics/atlas/FlxAtlas.hx",815,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 816)		this->_tempStorage = null();
HXLINE( 817)		this->deleteSubtree(this->root);
HXLINE( 818)		this->root = null();
HXLINE( 819)		::flixel::FlxG_obj::bitmap->removeByKey(this->name);
HXLINE( 820)		this->set_bitmapData(null());
HXLINE( 821)		this->nodes = null();
HXLINE( 822)		this->_graphic = null();
HXLINE( 824)		::flixel::FlxG_obj::signals->preStateCreate->remove(this->onClear_dyn());
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,destroy,(void))

void FlxAtlas_obj::clear(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","clear",0x59297dac,"flixel.graphics.atlas.FlxAtlas.clear","flixel/graphics/atlas/FlxAtlas.hx",832,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 833)		this->deleteSubtree(this->root);
HXLINE( 834)		this->initRoot();
HXLINE( 835)		::flixel::FlxG_obj::bitmap->removeByKey(this->name);
HXLINE( 836)		this->set_bitmapData(null());
HXLINE( 837)		this->nodes =  ::haxe::ds::StringMap_obj::__new();
HXLINE( 838)		this->_graphic = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,clear,(void))

::String FlxAtlas_obj::getLibGdxData(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","getLibGdxData",0x1a9c9615,"flixel.graphics.atlas.FlxAtlas.getLibGdxData","flixel/graphics/atlas/FlxAtlas.hx",845,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 846)		HX_VARI( ::String,data) = HX_("\n",0a,00,00,00);
HXLINE( 847)		data = (HX_("\n",0a,00,00,00) + (this->name + HX_("\n",0a,00,00,00)));
HXLINE( 848)		hx::AddEq(data,HX_("format: RGBA8888\n",99,1f,ed,c2));
HXLINE( 849)		hx::AddEq(data,HX_("filter: Linear,Linear\n",9c,47,05,72));
HXLINE( 850)		hx::AddEq(data,HX_("repeat: none\n",f1,9b,51,ee));
HXLINE( 852)		{
HXLINE( 852)			HX_VARI(  ::Dynamic,tmp) = this->nodes->iterator();
HXDLIN( 852)			while(true){
HXLINE( 852)				Bool _hx_tmp = !(( (Bool)( ::Dynamic(tmp->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic))()) ));
HXDLIN( 852)				if (_hx_tmp) {
HXLINE( 852)					goto _hx_goto_4;
            				}
HXDLIN( 852)				HX_VARI(  ::flixel::graphics::atlas::FlxNode,node) = ( ( ::flixel::graphics::atlas::FlxNode)( ::Dynamic(tmp->__Field(HX_("next",f3,84,02,49),hx::paccDynamic))()) );
HXLINE( 854)				hx::AddEq(data,(node->key + HX_("\n",0a,00,00,00)));
HXLINE( 855)				::String _hx_tmp1 = ::Std_obj::string(node->rotated);
HXDLIN( 855)				hx::AddEq(data,((HX_("  rotate: ",c1,21,ff,6f) + _hx_tmp1) + HX_("\n",0a,00,00,00)));
HXLINE( 856)				Int _hx_tmp2 = ::Std_obj::_hx_int(node->rect->x);
HXDLIN( 856)				::String _hx_tmp3 = ((HX_("  xy: ",e7,b9,eb,87) + _hx_tmp2) + HX_(", ",74,26,00,00));
HXDLIN( 856)				Int _hx_tmp4 = ::Std_obj::_hx_int(node->rect->y);
HXDLIN( 856)				hx::AddEq(data,((_hx_tmp3 + _hx_tmp4) + HX_("\n",0a,00,00,00)));
HXLINE( 858)				Bool _hx_tmp5 = this->allowRotation;
HXDLIN( 858)				if (_hx_tmp5) {
HXLINE( 860)					Int _hx_tmp6 = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 860)					::String _hx_tmp7 = ((HX_("size: ",a7,45,0e,c1) + _hx_tmp6) + HX_(", ",74,26,00,00));
HXDLIN( 860)					Int _hx_tmp8 = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 860)					hx::AddEq(data,((_hx_tmp7 + _hx_tmp8) + HX_("\n",0a,00,00,00)));
HXLINE( 861)					Int _hx_tmp9 = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 861)					::String _hx_tmp10 = ((HX_("orig: ",a7,f0,00,4b) + _hx_tmp9) + HX_(", ",74,26,00,00));
HXDLIN( 861)					Int _hx_tmp11 = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 861)					hx::AddEq(data,((_hx_tmp10 + _hx_tmp11) + HX_("\n",0a,00,00,00)));
            				}
            				else {
HXLINE( 865)					Int _hx_tmp12 = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 865)					::String _hx_tmp13 = ((HX_("size: ",a7,45,0e,c1) + _hx_tmp12) + HX_(", ",74,26,00,00));
HXDLIN( 865)					Int _hx_tmp14 = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 865)					hx::AddEq(data,((_hx_tmp13 + _hx_tmp14) + HX_("\n",0a,00,00,00)));
HXLINE( 866)					Int _hx_tmp15 = ::Std_obj::_hx_int(node->rect->width);
HXDLIN( 866)					::String _hx_tmp16 = ((HX_("orig: ",a7,f0,00,4b) + _hx_tmp15) + HX_(", ",74,26,00,00));
HXDLIN( 866)					Int _hx_tmp17 = ::Std_obj::_hx_int(node->rect->height);
HXDLIN( 866)					hx::AddEq(data,((_hx_tmp16 + _hx_tmp17) + HX_("\n",0a,00,00,00)));
            				}
HXLINE( 869)				hx::AddEq(data,HX_("  offset: 0, 0\n",e5,55,b9,3b));
HXLINE( 870)				hx::AddEq(data,HX_("  index: -1\n",ee,e8,07,0b));
            			}
            			_hx_goto_4:;
            		}
HXLINE( 873)		return data;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,getLibGdxData,return )

void FlxAtlas_obj::deleteSubtree( ::flixel::graphics::atlas::FlxNode node){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","deleteSubtree",0xf9ad5912,"flixel.graphics.atlas.FlxAtlas.deleteSubtree","flixel/graphics/atlas/FlxAtlas.hx",878,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(node,"node")
HXLINE( 878)		Bool _hx_tmp = hx::IsNotNull( node );
HXDLIN( 878)		if (_hx_tmp) {
HXLINE( 880)			Bool _hx_tmp1 = hx::IsNotNull( node->left );
HXDLIN( 880)			if (_hx_tmp1) {
HXLINE( 880)				this->deleteSubtree(node->left);
            			}
HXLINE( 881)			Bool _hx_tmp2 = hx::IsNotNull( node->right );
HXDLIN( 881)			if (_hx_tmp2) {
HXLINE( 881)				this->deleteSubtree(node->right);
            			}
HXLINE( 882)			{
HXLINE( 882)				node->key = null();
HXDLIN( 882)				node->left = null();
HXDLIN( 882)				node->right = null();
HXDLIN( 882)				node->rect = null();
HXDLIN( 882)				node->atlas = null();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,deleteSubtree,(void))

 ::flixel::graphics::atlas::FlxNode FlxAtlas_obj::findNodeToInsert(Int insertWidth,Int insertHeight){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","findNodeToInsert",0x513a4b50,"flixel.graphics.atlas.FlxAtlas.findNodeToInsert","flixel/graphics/atlas/FlxAtlas.hx",888,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(insertWidth,"insertWidth")
            	HX_STACK_ARG(insertHeight,"insertHeight")
HXLINE( 890)		HX_VARI( ::Array< ::Dynamic>,stack) = ::Array_obj< ::Dynamic>::__new();
HXLINE( 892)		HX_VARI(  ::flixel::graphics::atlas::FlxNode,current) = this->root;
HXLINE( 894)		::Array_obj< ::Dynamic>::__new();
HXLINE( 896)		HX_VARI( Bool,canPlaceRight) = false;
HXLINE( 897)		HX_VARI( Bool,canPlaceLeft) = false;
HXLINE( 899)		HX_VARI( Bool,looping) = true;
HXLINE( 901)		HX_VARI(  ::flixel::graphics::atlas::FlxNode,result) = null();
HXLINE( 902)		HX_VARI( Int,minArea) = ((this->maxWidth * this->maxHeight) + (int)1);
HXLINE( 903)		HX_VAR( Int,nodeArea);
HXLINE( 906)		while(looping){
HXLINE( 909)			Bool _hx_tmp;
HXDLIN( 909)			Bool _hx_tmp1;
HXDLIN( 909)			Bool _hx_tmp2;
HXDLIN( 909)			if (!(current->filled)) {
HXLINE( 909)				_hx_tmp2 = hx::IsNull( current->left );
            			}
            			else {
HXLINE( 909)				_hx_tmp2 = false;
            			}
HXDLIN( 909)			if (_hx_tmp2) {
HXLINE( 909)				_hx_tmp1 = hx::IsNull( current->right );
            			}
            			else {
HXLINE( 909)				_hx_tmp1 = false;
            			}
HXDLIN( 909)			if (_hx_tmp1) {
HXLINE( 909)				if ((current->rect->width >= insertWidth)) {
HXLINE( 909)					_hx_tmp = (current->rect->height >= insertHeight);
            				}
            				else {
HXLINE( 909)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 909)				_hx_tmp = false;
            			}
HXDLIN( 909)			if (_hx_tmp) {
HXLINE( 911)				Int _hx_tmp3 = ::Std_obj::_hx_int(current->rect->width);
HXDLIN( 911)				Int _hx_tmp4 = ::Std_obj::_hx_int(current->rect->height);
HXDLIN( 911)				nodeArea = (_hx_tmp3 * _hx_tmp4);
HXLINE( 913)				Bool _hx_tmp5 = (nodeArea < minArea);
HXDLIN( 913)				if (_hx_tmp5) {
HXLINE( 915)					minArea = nodeArea;
HXLINE( 916)					result = current;
            				}
            			}
HXLINE( 920)			Bool _hx_tmp6 = hx::IsNotNull( current->right );
HXDLIN( 920)			if (_hx_tmp6) {
HXLINE( 920)				HX_VARI(  ::flixel::graphics::atlas::FlxNode,_this) = current->right;
HXDLIN( 920)				if ((_this->rect->width >= insertWidth)) {
HXLINE( 920)					canPlaceRight = (_this->rect->height >= insertHeight);
            				}
            				else {
HXLINE( 920)					canPlaceRight = false;
            				}
            			}
            			else {
HXLINE( 920)				canPlaceRight = false;
            			}
HXLINE( 921)			Bool _hx_tmp7 = hx::IsNotNull( current->left );
HXDLIN( 921)			if (_hx_tmp7) {
HXLINE( 921)				HX_VARI_NAME(  ::flixel::graphics::atlas::FlxNode,_this1,"_this") = current->left;
HXDLIN( 921)				if ((_this1->rect->width >= insertWidth)) {
HXLINE( 921)					canPlaceLeft = (_this1->rect->height >= insertHeight);
            				}
            				else {
HXLINE( 921)					canPlaceLeft = false;
            				}
            			}
            			else {
HXLINE( 921)				canPlaceLeft = false;
            			}
HXLINE( 922)			Bool _hx_tmp8;
HXDLIN( 922)			if (canPlaceRight) {
HXLINE( 922)				_hx_tmp8 = canPlaceLeft;
            			}
            			else {
HXLINE( 922)				_hx_tmp8 = false;
            			}
HXDLIN( 922)			if (_hx_tmp8) {
HXLINE( 924)				stack->push(current->right);
HXLINE( 925)				current = current->left;
            			}
            			else {
HXLINE( 927)				if (canPlaceLeft) {
HXLINE( 929)					current = current->left;
            				}
            				else {
HXLINE( 931)					if (canPlaceRight) {
HXLINE( 933)						current = current->right;
            					}
            					else {
HXLINE( 937)						Bool _hx_tmp9 = (stack->length > (int)0);
HXDLIN( 937)						if (_hx_tmp9) {
HXLINE( 940)							current = stack->pop().StaticCast<  ::flixel::graphics::atlas::FlxNode >();
            						}
            						else {
HXLINE( 945)							looping = false;
            						}
            					}
            				}
            			}
            		}
HXLINE( 950)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAtlas_obj,findNodeToInsert,return )

 ::openfl::_legacy::display::BitmapData FlxAtlas_obj::set_bitmapData( ::openfl::_legacy::display::BitmapData value){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","set_bitmapData",0xf5eb1e77,"flixel.graphics.atlas.FlxAtlas.set_bitmapData","flixel/graphics/atlas/FlxAtlas.hx",954,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 955)		Bool _hx_tmp = hx::IsNotNull( value );
HXDLIN( 955)		if (_hx_tmp) {
HXLINE( 958)			Bool _hx_tmp1 = hx::IsNotNull( this->_graphic );
HXDLIN( 958)			if (_hx_tmp1) {
HXLINE( 960)				this->_graphic->set_bitmap(value);
            			}
            		}
HXLINE( 964)		return (this->bitmapData = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_bitmapData,return )

 ::flixel::graphics::FlxGraphic FlxAtlas_obj::get_graphic(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","get_graphic",0xa3fa281e,"flixel.graphics.atlas.FlxAtlas.get_graphic","flixel/graphics/atlas/FlxAtlas.hx",968,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE( 969)		Bool _hx_tmp = hx::IsNotNull( this->_graphic );
HXDLIN( 969)		if (_hx_tmp) {
HXLINE( 970)			return this->_graphic;
            		}
HXLINE( 972)		this->_graphic = ::flixel::FlxG_obj::bitmap->add(this->bitmapData,false,this->name);
HXLINE( 973)		this->_graphic->persist = this->persist;
HXLINE( 975)		return this->_graphic;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,get_graphic,return )

Bool FlxAtlas_obj::set_persist(Bool value){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","set_persist",0xbdd0f696,"flixel.graphics.atlas.FlxAtlas.set_persist","flixel/graphics/atlas/FlxAtlas.hx",979,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 980)		Bool _hx_tmp = hx::IsNotNull( this->_graphic );
HXDLIN( 980)		if (_hx_tmp) {
HXLINE( 981)			this->_graphic->persist = value;
            		}
HXLINE( 983)		return (this->persist = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_persist,return )

Int FlxAtlas_obj::set_minWidth(Int value){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","set_minWidth",0x9b144052,"flixel.graphics.atlas.FlxAtlas.set_minWidth","flixel/graphics/atlas/FlxAtlas.hx",987,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE( 988)		Bool _hx_tmp = (value <= this->maxWidth);
HXDLIN( 988)		if (_hx_tmp) {
HXLINE( 990)			this->minWidth = value;
HXLINE( 992)			Int _hx_tmp1 = this->get_width();
HXDLIN( 992)			if ((value > _hx_tmp1)) {
HXLINE( 994)				this->set_width(value);
            			}
            		}
HXLINE( 998)		return this->minWidth;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_minWidth,return )

Int FlxAtlas_obj::set_minHeight(Int value){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","set_minHeight",0xccf3801b,"flixel.graphics.atlas.FlxAtlas.set_minHeight","flixel/graphics/atlas/FlxAtlas.hx",1002,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1003)		Bool _hx_tmp = (value <= this->maxHeight);
HXDLIN(1003)		if (_hx_tmp) {
HXLINE(1005)			this->minHeight = value;
HXLINE(1007)			Int _hx_tmp1 = this->get_height();
HXDLIN(1007)			if ((value > _hx_tmp1)) {
HXLINE(1009)				this->set_height(value);
            			}
            		}
HXLINE(1013)		return this->minHeight;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_minHeight,return )

Int FlxAtlas_obj::get_width(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","get_width",0x463c19fc,"flixel.graphics.atlas.FlxAtlas.get_width","flixel/graphics/atlas/FlxAtlas.hx",1017,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE(1018)		Bool _hx_tmp = hx::IsNotNull( this->root );
HXDLIN(1018)		if (_hx_tmp) {
HXLINE(1020)			return ::Std_obj::_hx_int(this->root->rect->width);
            		}
HXLINE(1023)		return (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,get_width,return )

Int FlxAtlas_obj::set_width(Int value){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","set_width",0x298d0608,"flixel.graphics.atlas.FlxAtlas.set_width","flixel/graphics/atlas/FlxAtlas.hx",1027,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1028)		Int _hx_tmp = this->get_width();
HXDLIN(1028)		if ((value > _hx_tmp)) {
HXLINE(1030)			Bool _hx_tmp1 = this->powerOfTwo;
HXDLIN(1030)			if (_hx_tmp1) {
HXLINE(1032)				value = this->getNextPowerOfTwo(value);
            			}
HXLINE(1035)			Bool _hx_tmp2 = (value <= this->maxWidth);
HXDLIN(1035)			if (_hx_tmp2) {
HXLINE(1037)				Bool _hx_tmp3;
HXDLIN(1037)				Bool _hx_tmp4 = hx::IsNotNull( this->root );
HXDLIN(1037)				if (_hx_tmp4) {
HXLINE(1037)					Int _hx_tmp5 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN(1037)					_hx_tmp3 = (_hx_tmp5 < value);
            				}
            				else {
HXLINE(1037)					_hx_tmp3 = false;
            				}
HXDLIN(1037)				if (_hx_tmp3) {
HXLINE(1039)					Int _hx_tmp6 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN(1039)					Int _hx_tmp7 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN(1039)					Int _hx_tmp8 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN(1039)					Bool _hx_tmp9 = this->needToDivideHorizontally(this->root,_hx_tmp7,_hx_tmp8);
HXDLIN(1039)					this->expandRoot(value,_hx_tmp6,_hx_tmp9,null());
            				}
            			}
            		}
HXLINE(1044)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_width,return )

Int FlxAtlas_obj::get_height(){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","get_height",0xe4aa1b31,"flixel.graphics.atlas.FlxAtlas.get_height","flixel/graphics/atlas/FlxAtlas.hx",1048,0x03972f50)
            	HX_STACK_THIS(this)
HXLINE(1049)		Bool _hx_tmp = hx::IsNotNull( this->root );
HXDLIN(1049)		if (_hx_tmp) {
HXLINE(1051)			return ::Std_obj::_hx_int(this->root->rect->height);
            		}
HXLINE(1054)		return (int)0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxAtlas_obj,get_height,return )

Int FlxAtlas_obj::set_height(Int value){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","set_height",0xe827b9a5,"flixel.graphics.atlas.FlxAtlas.set_height","flixel/graphics/atlas/FlxAtlas.hx",1058,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1059)		Int _hx_tmp = this->get_height();
HXDLIN(1059)		if ((value > _hx_tmp)) {
HXLINE(1061)			Bool _hx_tmp1 = this->powerOfTwo;
HXDLIN(1061)			if (_hx_tmp1) {
HXLINE(1063)				value = this->getNextPowerOfTwo(value);
            			}
HXLINE(1066)			Bool _hx_tmp2 = (value <= this->maxHeight);
HXDLIN(1066)			if (_hx_tmp2) {
HXLINE(1068)				Bool _hx_tmp3;
HXDLIN(1068)				Bool _hx_tmp4 = hx::IsNotNull( this->root );
HXDLIN(1068)				if (_hx_tmp4) {
HXLINE(1068)					Int _hx_tmp5 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN(1068)					_hx_tmp3 = (_hx_tmp5 < value);
            				}
            				else {
HXLINE(1068)					_hx_tmp3 = false;
            				}
HXDLIN(1068)				if (_hx_tmp3) {
HXLINE(1070)					Int _hx_tmp6 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN(1070)					Int _hx_tmp7 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN(1070)					Int _hx_tmp8 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN(1070)					Bool _hx_tmp9 = this->needToDivideHorizontally(this->root,_hx_tmp7,_hx_tmp8);
HXDLIN(1070)					this->expandRoot(_hx_tmp6,value,_hx_tmp9,null());
            				}
            			}
            		}
HXLINE(1075)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_height,return )

Int FlxAtlas_obj::set_maxWidth(Int value){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","set_maxWidth",0x4dfa2600,"flixel.graphics.atlas.FlxAtlas.set_maxWidth","flixel/graphics/atlas/FlxAtlas.hx",1079,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1080)		Bool _hx_tmp;
HXDLIN(1080)		Bool _hx_tmp1 = (value >= this->minWidth);
HXDLIN(1080)		if (_hx_tmp1) {
HXLINE(1080)			Bool _hx_tmp2 = hx::IsNotNull( this->root );
HXDLIN(1080)			if (_hx_tmp2) {
HXLINE(1080)				Int _hx_tmp3 = this->get_width();
HXDLIN(1080)				_hx_tmp = (value >= _hx_tmp3);
            			}
            			else {
HXLINE(1080)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE(1080)			_hx_tmp = false;
            		}
HXDLIN(1080)		if (_hx_tmp) {
HXLINE(1082)			this->maxWidth = value;
            		}
HXLINE(1085)		return this->maxWidth;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_maxWidth,return )

Int FlxAtlas_obj::set_maxHeight(Int value){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","set_maxHeight",0xa33692ad,"flixel.graphics.atlas.FlxAtlas.set_maxHeight","flixel/graphics/atlas/FlxAtlas.hx",1089,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1090)		Bool _hx_tmp;
HXDLIN(1090)		Bool _hx_tmp1 = (value >= this->minHeight);
HXDLIN(1090)		if (_hx_tmp1) {
HXLINE(1090)			Bool _hx_tmp2 = hx::IsNotNull( this->root );
HXDLIN(1090)			if (_hx_tmp2) {
HXLINE(1090)				Int _hx_tmp3 = this->get_height();
HXDLIN(1090)				_hx_tmp = (value >= _hx_tmp3);
            			}
            			else {
HXLINE(1090)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE(1090)			_hx_tmp = false;
            		}
HXDLIN(1090)		if (_hx_tmp) {
HXLINE(1092)			this->maxHeight = value;
            		}
HXLINE(1095)		return this->maxHeight;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_maxHeight,return )

Bool FlxAtlas_obj::set_powerOfTwo(Bool value){
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","set_powerOfTwo",0xacd9272e,"flixel.graphics.atlas.FlxAtlas.set_powerOfTwo","flixel/graphics/atlas/FlxAtlas.hx",1099,0x03972f50)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(value,"value")
HXLINE(1100)		Bool _hx_tmp;
HXDLIN(1100)		Bool _hx_tmp1;
HXDLIN(1100)		if ((value != this->powerOfTwo)) {
HXLINE(1100)			_hx_tmp1 = value;
            		}
            		else {
HXLINE(1100)			_hx_tmp1 = false;
            		}
HXDLIN(1100)		if (_hx_tmp1) {
HXLINE(1100)			_hx_tmp = hx::IsNotNull( this->root );
            		}
            		else {
HXLINE(1100)			_hx_tmp = false;
            		}
HXDLIN(1100)		if (_hx_tmp) {
HXLINE(1102)			Int _hx_tmp2 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN(1102)			HX_VARI( Int,nextWidth) = this->getNextPowerOfTwo(_hx_tmp2);
HXLINE(1103)			Int _hx_tmp3 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN(1103)			HX_VARI( Int,nextHeight) = this->getNextPowerOfTwo(_hx_tmp3);
HXLINE(1105)			Bool _hx_tmp4;
HXDLIN(1105)			Int _hx_tmp5 = ::Std_obj::_hx_int(this->root->rect->width);
HXDLIN(1105)			if ((nextWidth == _hx_tmp5)) {
HXLINE(1105)				Int _hx_tmp6 = ::Std_obj::_hx_int(this->root->rect->height);
HXDLIN(1105)				_hx_tmp4 = (nextHeight != _hx_tmp6);
            			}
            			else {
HXLINE(1105)				_hx_tmp4 = true;
            			}
HXDLIN(1105)			if (_hx_tmp4) {
HXLINE(1107)				Bool _hx_tmp7;
HXDLIN(1107)				Bool _hx_tmp8;
HXDLIN(1107)				if ((this->maxWidth > (int)0)) {
HXLINE(1107)					_hx_tmp8 = (nextWidth > this->maxWidth);
            				}
            				else {
HXLINE(1107)					_hx_tmp8 = false;
            				}
HXDLIN(1107)				if (!(_hx_tmp8)) {
HXLINE(1107)					if ((this->maxHeight > (int)0)) {
HXLINE(1107)						_hx_tmp7 = (nextHeight > this->maxHeight);
            					}
            					else {
HXLINE(1107)						_hx_tmp7 = false;
            					}
            				}
            				else {
HXLINE(1107)					_hx_tmp7 = true;
            				}
HXDLIN(1107)				if (_hx_tmp7) {
HXLINE(1110)					HX_STACK_DO_THROW(HX_("Can't set powerOfTwo property to true, since it requires to increase atlas size which is bigger that max size",9a,7f,9f,bb));
            				}
HXLINE(1115)				HX_VARI(  ::flixel::graphics::atlas::FlxNode,temp) = this->root;
HXLINE(1116)				HX_VARI(  ::flixel::math::FlxRect,_this) = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN(1116)				_this->x = (int)0;
HXDLIN(1116)				_this->y = (int)0;
HXDLIN(1116)				_this->width = nextWidth;
HXDLIN(1116)				_this->height = nextHeight;
HXDLIN(1116)				_this->_inPool = false;
HXDLIN(1116)				this->root =  ::flixel::graphics::atlas::FlxNode_obj::__new(_this,hx::ObjectPtr<OBJ_>(this),null(),null(),null());
HXLINE(1118)				Bool _hx_tmp9 = hx::IsNotNull( temp->left );
HXDLIN(1118)				if (_hx_tmp9) {
HXLINE(1120)					Int _hx_tmp10 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN(1120)					Int _hx_tmp11 = ::Std_obj::_hx_int(temp->rect->height);
HXDLIN(1120)					Int _hx_tmp12 = ::Std_obj::_hx_int(temp->rect->width);
HXDLIN(1120)					Int _hx_tmp13 = ::Std_obj::_hx_int(temp->rect->height);
HXDLIN(1120)					Bool _hx_tmp14 = this->needToDivideHorizontally(this->root,_hx_tmp12,_hx_tmp13);
HXDLIN(1120)					this->divideNode(this->root,_hx_tmp10,_hx_tmp11,_hx_tmp14,null(),null(),null());
HXLINE(1121)					this->root->left->left = temp;
            				}
            			}
            		}
HXLINE(1126)		return (this->powerOfTwo = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAtlas_obj,set_powerOfTwo,return )

 ::openfl::_legacy::geom::Point FlxAtlas_obj::point;

 ::openfl::_legacy::geom::Matrix FlxAtlas_obj::matrix;

 ::flixel::math::FlxPoint FlxAtlas_obj::defaultMinSize;

 ::flixel::math::FlxPoint FlxAtlas_obj::defaultMaxSize;


FlxAtlas_obj::FlxAtlas_obj()
{
}

void FlxAtlas_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxAtlas);
	HX_MARK_MEMBER_NAME(root,"root");
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(nodes,"nodes");
	HX_MARK_MEMBER_NAME(bitmapData,"bitmapData");
	HX_MARK_MEMBER_NAME(graphic,"graphic");
	HX_MARK_MEMBER_NAME(persist,"persist");
	HX_MARK_MEMBER_NAME(border,"border");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(minWidth,"minWidth");
	HX_MARK_MEMBER_NAME(minHeight,"minHeight");
	HX_MARK_MEMBER_NAME(maxWidth,"maxWidth");
	HX_MARK_MEMBER_NAME(maxHeight,"maxHeight");
	HX_MARK_MEMBER_NAME(allowRotation,"allowRotation");
	HX_MARK_MEMBER_NAME(powerOfTwo,"powerOfTwo");
	HX_MARK_MEMBER_NAME(_graphic,"_graphic");
	HX_MARK_MEMBER_NAME(_tempStorage,"_tempStorage");
	HX_MARK_END_CLASS();
}

void FlxAtlas_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(root,"root");
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(nodes,"nodes");
	HX_VISIT_MEMBER_NAME(bitmapData,"bitmapData");
	HX_VISIT_MEMBER_NAME(graphic,"graphic");
	HX_VISIT_MEMBER_NAME(persist,"persist");
	HX_VISIT_MEMBER_NAME(border,"border");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(minWidth,"minWidth");
	HX_VISIT_MEMBER_NAME(minHeight,"minHeight");
	HX_VISIT_MEMBER_NAME(maxWidth,"maxWidth");
	HX_VISIT_MEMBER_NAME(maxHeight,"maxHeight");
	HX_VISIT_MEMBER_NAME(allowRotation,"allowRotation");
	HX_VISIT_MEMBER_NAME(powerOfTwo,"powerOfTwo");
	HX_VISIT_MEMBER_NAME(_graphic,"_graphic");
	HX_VISIT_MEMBER_NAME(_tempStorage,"_tempStorage");
}

hx::Val FlxAtlas_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"root") ) { return hx::Val( root); }
		if (HX_FIELD_EQ(inName,"name") ) { return hx::Val( name); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"nodes") ) { return hx::Val( nodes); }
		if (HX_FIELD_EQ(inName,"width") ) { return hx::Val( inCallProp == hx::paccAlways ? get_width() : width); }
		if (HX_FIELD_EQ(inName,"clear") ) { return hx::Val( clear_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"border") ) { return hx::Val( border); }
		if (HX_FIELD_EQ(inName,"height") ) { return hx::Val( inCallProp == hx::paccAlways ? get_height() : height); }
		if (HX_FIELD_EQ(inName,"expand") ) { return hx::Val( expand_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { return hx::Val( inCallProp == hx::paccAlways ? get_graphic() : graphic); }
		if (HX_FIELD_EQ(inName,"persist") ) { return hx::Val( persist); }
		if (HX_FIELD_EQ(inName,"addNode") ) { return hx::Val( addNode_dyn()); }
		if (HX_FIELD_EQ(inName,"getNode") ) { return hx::Val( getNode_dyn()); }
		if (HX_FIELD_EQ(inName,"onClear") ) { return hx::Val( onClear_dyn()); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"minWidth") ) { return hx::Val( minWidth); }
		if (HX_FIELD_EQ(inName,"maxWidth") ) { return hx::Val( maxWidth); }
		if (HX_FIELD_EQ(inName,"_graphic") ) { return hx::Val( _graphic); }
		if (HX_FIELD_EQ(inName,"initRoot") ) { return hx::Val( initRoot_dyn()); }
		if (HX_FIELD_EQ(inName,"wrapRoot") ) { return hx::Val( wrapRoot_dyn()); }
		if (HX_FIELD_EQ(inName,"addNodes") ) { return hx::Val( addNodes_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"minHeight") ) { return hx::Val( minHeight); }
		if (HX_FIELD_EQ(inName,"maxHeight") ) { return hx::Val( maxHeight); }
		if (HX_FIELD_EQ(inName,"tryInsert") ) { return hx::Val( tryInsert_dyn()); }
		if (HX_FIELD_EQ(inName,"get_width") ) { return hx::Val( get_width_dyn()); }
		if (HX_FIELD_EQ(inName,"set_width") ) { return hx::Val( set_width_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bitmapData") ) { return hx::Val( bitmapData); }
		if (HX_FIELD_EQ(inName,"powerOfTwo") ) { return hx::Val( powerOfTwo); }
		if (HX_FIELD_EQ(inName,"divideNode") ) { return hx::Val( divideNode_dyn()); }
		if (HX_FIELD_EQ(inName,"expandRoot") ) { return hx::Val( expandRoot_dyn()); }
		if (HX_FIELD_EQ(inName,"addToQueue") ) { return hx::Val( addToQueue_dyn()); }
		if (HX_FIELD_EQ(inName,"get_height") ) { return hx::Val( get_height_dyn()); }
		if (HX_FIELD_EQ(inName,"set_height") ) { return hx::Val( set_height_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"createQueue") ) { return hx::Val( createQueue_dyn()); }
		if (HX_FIELD_EQ(inName,"get_graphic") ) { return hx::Val( get_graphic_dyn()); }
		if (HX_FIELD_EQ(inName,"set_persist") ) { return hx::Val( set_persist_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_tempStorage") ) { return hx::Val( _tempStorage); }
		if (HX_FIELD_EQ(inName,"bitmapSorter") ) { return hx::Val( bitmapSorter_dyn()); }
		if (HX_FIELD_EQ(inName,"set_minWidth") ) { return hx::Val( set_minWidth_dyn()); }
		if (HX_FIELD_EQ(inName,"set_maxWidth") ) { return hx::Val( set_maxWidth_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"allowRotation") ) { return hx::Val( allowRotation); }
		if (HX_FIELD_EQ(inName,"getLibGdxData") ) { return hx::Val( getLibGdxData_dyn()); }
		if (HX_FIELD_EQ(inName,"deleteSubtree") ) { return hx::Val( deleteSubtree_dyn()); }
		if (HX_FIELD_EQ(inName,"set_minHeight") ) { return hx::Val( set_minHeight_dyn()); }
		if (HX_FIELD_EQ(inName,"set_maxHeight") ) { return hx::Val( set_maxHeight_dyn()); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getAtlasFrames") ) { return hx::Val( getAtlasFrames_dyn()); }
		if (HX_FIELD_EQ(inName,"set_bitmapData") ) { return hx::Val( set_bitmapData_dyn()); }
		if (HX_FIELD_EQ(inName,"set_powerOfTwo") ) { return hx::Val( set_powerOfTwo_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"hasNodeWithName") ) { return hx::Val( hasNodeWithName_dyn()); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"expandBitmapData") ) { return hx::Val( expandBitmapData_dyn()); }
		if (HX_FIELD_EQ(inName,"findNodeToInsert") ) { return hx::Val( findNodeToInsert_dyn()); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getNextPowerOfTwo") ) { return hx::Val( getNextPowerOfTwo_dyn()); }
		if (HX_FIELD_EQ(inName,"generateFromQueue") ) { return hx::Val( generateFromQueue_dyn()); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"addFromAtlasObjects") ) { return hx::Val( addFromAtlasObjects_dyn()); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"addNodeToAtlasFrames") ) { return hx::Val( addNodeToAtlasFrames_dyn()); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"insertFirstNodeInRoot") ) { return hx::Val( insertFirstNodeInRoot_dyn()); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"needToDivideHorizontally") ) { return hx::Val( needToDivideHorizontally_dyn()); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"addNodeWithSpacesAndBorders") ) { return hx::Val( addNodeWithSpacesAndBorders_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxAtlas_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"point") ) { outValue = point; return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { outValue = matrix; return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"defaultMinSize") ) { outValue = defaultMinSize; return true; }
		if (HX_FIELD_EQ(inName,"defaultMaxSize") ) { outValue = defaultMaxSize; return true; }
	}
	return false;
}

hx::Val FlxAtlas_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"root") ) { root=inValue.Cast<  ::flixel::graphics::atlas::FlxNode >(); return inValue; }
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"nodes") ) { nodes=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"width") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_width(inValue) );width=inValue.Cast< Int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"border") ) { border=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"height") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_height(inValue) );height=inValue.Cast< Int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { graphic=inValue.Cast<  ::flixel::graphics::FlxGraphic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"persist") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_persist(inValue) );persist=inValue.Cast< Bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"minWidth") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_minWidth(inValue) );minWidth=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxWidth") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_maxWidth(inValue) );maxWidth=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_graphic") ) { _graphic=inValue.Cast<  ::flixel::graphics::FlxGraphic >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"minHeight") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_minHeight(inValue) );minHeight=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxHeight") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_maxHeight(inValue) );maxHeight=inValue.Cast< Int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bitmapData") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_bitmapData(inValue) );bitmapData=inValue.Cast<  ::openfl::_legacy::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"powerOfTwo") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_powerOfTwo(inValue) );powerOfTwo=inValue.Cast< Bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_tempStorage") ) { _tempStorage=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"allowRotation") ) { allowRotation=inValue.Cast< Bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxAtlas_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"point") ) { point=ioValue.Cast<  ::openfl::_legacy::geom::Point >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { matrix=ioValue.Cast<  ::openfl::_legacy::geom::Matrix >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"defaultMinSize") ) { defaultMinSize=ioValue.Cast<  ::flixel::math::FlxPoint >(); return true; }
		if (HX_FIELD_EQ(inName,"defaultMaxSize") ) { defaultMaxSize=ioValue.Cast<  ::flixel::math::FlxPoint >(); return true; }
	}
	return false;
}

void FlxAtlas_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("root","\x22","\xee","\xae","\x4b"));
	outFields->push(HX_HCSTRING("name","\x4b","\x72","\xff","\x48"));
	outFields->push(HX_HCSTRING("nodes","\x31","\xb8","\xbe","\x9f"));
	outFields->push(HX_HCSTRING("bitmapData","\xb9","\xb5","\xc0","\x33"));
	outFields->push(HX_HCSTRING("graphic","\xa8","\x5a","\x07","\x74"));
	outFields->push(HX_HCSTRING("persist","\x14","\x22","\x71","\x83"));
	outFields->push(HX_HCSTRING("border","\xec","\x4c","\x1a","\x64"));
	outFields->push(HX_HCSTRING("width","\x06","\xb6","\x62","\xca"));
	outFields->push(HX_HCSTRING("height","\xe7","\x07","\x4c","\x02"));
	outFields->push(HX_HCSTRING("minWidth","\x14","\x23","\x9a","\xc1"));
	outFields->push(HX_HCSTRING("minHeight","\x19","\x07","\x94","\x5b"));
	outFields->push(HX_HCSTRING("maxWidth","\xc2","\x08","\x80","\x74"));
	outFields->push(HX_HCSTRING("maxHeight","\xab","\x19","\xd7","\x31"));
	outFields->push(HX_HCSTRING("allowRotation","\xe7","\xce","\x40","\xd9"));
	outFields->push(HX_HCSTRING("powerOfTwo","\x70","\xbe","\xae","\xea"));
	outFields->push(HX_HCSTRING("_graphic","\x29","\xb4","\xbf","\xad"));
	outFields->push(HX_HCSTRING("_tempStorage","\x88","\x3c","\x09","\x91"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo FlxAtlas_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::flixel::graphics::atlas::FlxNode*/ ,(int)offsetof(FlxAtlas_obj,root),HX_HCSTRING("root","\x22","\xee","\xae","\x4b")},
	{hx::fsString,(int)offsetof(FlxAtlas_obj,name),HX_HCSTRING("name","\x4b","\x72","\xff","\x48")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(FlxAtlas_obj,nodes),HX_HCSTRING("nodes","\x31","\xb8","\xbe","\x9f")},
	{hx::fsObject /*::openfl::_legacy::display::BitmapData*/ ,(int)offsetof(FlxAtlas_obj,bitmapData),HX_HCSTRING("bitmapData","\xb9","\xb5","\xc0","\x33")},
	{hx::fsObject /*::flixel::graphics::FlxGraphic*/ ,(int)offsetof(FlxAtlas_obj,graphic),HX_HCSTRING("graphic","\xa8","\x5a","\x07","\x74")},
	{hx::fsBool,(int)offsetof(FlxAtlas_obj,persist),HX_HCSTRING("persist","\x14","\x22","\x71","\x83")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,border),HX_HCSTRING("border","\xec","\x4c","\x1a","\x64")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,width),HX_HCSTRING("width","\x06","\xb6","\x62","\xca")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,height),HX_HCSTRING("height","\xe7","\x07","\x4c","\x02")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,minWidth),HX_HCSTRING("minWidth","\x14","\x23","\x9a","\xc1")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,minHeight),HX_HCSTRING("minHeight","\x19","\x07","\x94","\x5b")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,maxWidth),HX_HCSTRING("maxWidth","\xc2","\x08","\x80","\x74")},
	{hx::fsInt,(int)offsetof(FlxAtlas_obj,maxHeight),HX_HCSTRING("maxHeight","\xab","\x19","\xd7","\x31")},
	{hx::fsBool,(int)offsetof(FlxAtlas_obj,allowRotation),HX_HCSTRING("allowRotation","\xe7","\xce","\x40","\xd9")},
	{hx::fsBool,(int)offsetof(FlxAtlas_obj,powerOfTwo),HX_HCSTRING("powerOfTwo","\x70","\xbe","\xae","\xea")},
	{hx::fsObject /*::flixel::graphics::FlxGraphic*/ ,(int)offsetof(FlxAtlas_obj,_graphic),HX_HCSTRING("_graphic","\x29","\xb4","\xbf","\xad")},
	{hx::fsObject /*cpp::ArrayBase*/ ,(int)offsetof(FlxAtlas_obj,_tempStorage),HX_HCSTRING("_tempStorage","\x88","\x3c","\x09","\x91")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo FlxAtlas_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::openfl::_legacy::geom::Point*/ ,(void *) &FlxAtlas_obj::point,HX_HCSTRING("point","\x50","\xb4","\x8f","\xc6")},
	{hx::fsObject /*::openfl::_legacy::geom::Matrix*/ ,(void *) &FlxAtlas_obj::matrix,HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(void *) &FlxAtlas_obj::defaultMinSize,HX_HCSTRING("defaultMinSize","\xb2","\x68","\x9d","\x6c")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(void *) &FlxAtlas_obj::defaultMaxSize,HX_HCSTRING("defaultMaxSize","\xc4","\x52","\xc4","\xfb")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxAtlas_obj_sMemberFields[] = {
	HX_HCSTRING("root","\x22","\xee","\xae","\x4b"),
	HX_HCSTRING("name","\x4b","\x72","\xff","\x48"),
	HX_HCSTRING("nodes","\x31","\xb8","\xbe","\x9f"),
	HX_HCSTRING("bitmapData","\xb9","\xb5","\xc0","\x33"),
	HX_HCSTRING("graphic","\xa8","\x5a","\x07","\x74"),
	HX_HCSTRING("persist","\x14","\x22","\x71","\x83"),
	HX_HCSTRING("border","\xec","\x4c","\x1a","\x64"),
	HX_HCSTRING("width","\x06","\xb6","\x62","\xca"),
	HX_HCSTRING("height","\xe7","\x07","\x4c","\x02"),
	HX_HCSTRING("minWidth","\x14","\x23","\x9a","\xc1"),
	HX_HCSTRING("minHeight","\x19","\x07","\x94","\x5b"),
	HX_HCSTRING("maxWidth","\xc2","\x08","\x80","\x74"),
	HX_HCSTRING("maxHeight","\xab","\x19","\xd7","\x31"),
	HX_HCSTRING("allowRotation","\xe7","\xce","\x40","\xd9"),
	HX_HCSTRING("powerOfTwo","\x70","\xbe","\xae","\xea"),
	HX_HCSTRING("_graphic","\x29","\xb4","\xbf","\xad"),
	HX_HCSTRING("_tempStorage","\x88","\x3c","\x09","\x91"),
	HX_HCSTRING("initRoot","\x52","\x1d","\x66","\x50"),
	HX_HCSTRING("addNode","\xc3","\x4c","\x47","\x85"),
	HX_HCSTRING("wrapRoot","\x0c","\x01","\x09","\x97"),
	HX_HCSTRING("tryInsert","\xd4","\x3e","\xf1","\x87"),
	HX_HCSTRING("needToDivideHorizontally","\x5b","\x7d","\xcf","\xa2"),
	HX_HCSTRING("divideNode","\x1b","\x16","\xb5","\x64"),
	HX_HCSTRING("insertFirstNodeInRoot","\x60","\x9d","\x55","\x94"),
	HX_HCSTRING("expand","\x5a","\xee","\x72","\xc4"),
	HX_HCSTRING("expandRoot","\x9c","\x3d","\x1a","\x4c"),
	HX_HCSTRING("expandBitmapData","\xb3","\xdc","\x4b","\xc7"),
	HX_HCSTRING("getNextPowerOfTwo","\x79","\xc4","\xc2","\xb5"),
	HX_HCSTRING("addNodeWithSpacesAndBorders","\xc6","\x41","\x7e","\xb4"),
	HX_HCSTRING("getAtlasFrames","\x5b","\x4e","\xd7","\xb6"),
	HX_HCSTRING("addNodeToAtlasFrames","\xd3","\xfe","\xb4","\xb1"),
	HX_HCSTRING("hasNodeWithName","\x0d","\x52","\xd4","\xd3"),
	HX_HCSTRING("getNode","\xb8","\xb9","\x8c","\x1b"),
	HX_HCSTRING("addNodes","\x50","\xde","\x1b","\x19"),
	HX_HCSTRING("addFromAtlasObjects","\x94","\x9b","\x21","\x50"),
	HX_HCSTRING("bitmapSorter","\x9a","\x34","\x57","\x3b"),
	HX_HCSTRING("createQueue","\xf5","\xc4","\x65","\x87"),
	HX_HCSTRING("addToQueue","\xf5","\x05","\xf9","\x91"),
	HX_HCSTRING("generateFromQueue","\xd2","\xe9","\x4a","\x08"),
	HX_HCSTRING("onClear","\xee","\x0f","\x99","\xde"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("clear","\x8d","\x71","\x5b","\x48"),
	HX_HCSTRING("getLibGdxData","\xf6","\xd2","\xa6","\xaf"),
	HX_HCSTRING("deleteSubtree","\xf3","\x95","\xb7","\x8e"),
	HX_HCSTRING("findNodeToInsert","\x0f","\x91","\xf6","\x3b"),
	HX_HCSTRING("set_bitmapData","\x76","\x26","\xd6","\xc9"),
	HX_HCSTRING("get_graphic","\xbf","\xba","\x01","\xfa"),
	HX_HCSTRING("set_persist","\x37","\x89","\xd8","\x13"),
	HX_HCSTRING("set_minWidth","\x91","\xfa","\xac","\x8b"),
	HX_HCSTRING("set_minHeight","\xfc","\xbc","\xfd","\x61"),
	HX_HCSTRING("get_width","\x5d","\x12","\x0c","\x0e"),
	HX_HCSTRING("set_width","\x69","\xfe","\x5c","\xf1"),
	HX_HCSTRING("get_height","\xb0","\x77","\xd3","\xf2"),
	HX_HCSTRING("set_height","\x24","\x16","\x51","\xf6"),
	HX_HCSTRING("set_maxWidth","\x3f","\xe0","\x92","\x3e"),
	HX_HCSTRING("set_maxHeight","\x8e","\xcf","\x40","\x38"),
	HX_HCSTRING("set_powerOfTwo","\x2d","\x2f","\xc4","\x80"),
	::String(null()) };

static void FlxAtlas_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::point,"point");
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::matrix,"matrix");
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::defaultMinSize,"defaultMinSize");
	HX_MARK_MEMBER_NAME(FlxAtlas_obj::defaultMaxSize,"defaultMaxSize");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxAtlas_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::point,"point");
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::matrix,"matrix");
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::defaultMinSize,"defaultMinSize");
	HX_VISIT_MEMBER_NAME(FlxAtlas_obj::defaultMaxSize,"defaultMaxSize");
};

#endif

hx::Class FlxAtlas_obj::__mClass;

static ::String FlxAtlas_obj_sStaticFields[] = {
	HX_HCSTRING("point","\x50","\xb4","\x8f","\xc6"),
	HX_HCSTRING("matrix","\x41","\x36","\xc8","\xbb"),
	HX_HCSTRING("defaultMinSize","\xb2","\x68","\x9d","\x6c"),
	HX_HCSTRING("defaultMaxSize","\xc4","\x52","\xc4","\xfb"),
	::String(null())
};

void FlxAtlas_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.graphics.atlas.FlxAtlas","\x4d","\x7b","\x60","\x52");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxAtlas_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxAtlas_obj::__SetStatic;
	__mClass->mMarkFunc = FlxAtlas_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxAtlas_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FlxAtlas_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FlxAtlas_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxAtlas_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxAtlas_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxAtlas_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxAtlas_obj::__boot()
{
{
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","boot",0x7e06a0f3,"flixel.graphics.atlas.FlxAtlas.boot","flixel/graphics/atlas/FlxAtlas.hx",27,0x03972f50)
HXLINE(  27)		point =  ::openfl::_legacy::geom::Point_obj::__new(null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","boot",0x7e06a0f3,"flixel.graphics.atlas.FlxAtlas.boot","flixel/graphics/atlas/FlxAtlas.hx",28,0x03972f50)
HXLINE(  28)		matrix =  ::openfl::_legacy::geom::Matrix_obj::__new(null(),null(),null(),null(),null(),null());
            	}
{
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","boot",0x7e06a0f3,"flixel.graphics.atlas.FlxAtlas.boot","flixel/graphics/atlas/FlxAtlas.hx",33,0x03972f50)
HXLINE(  33)		defaultMinSize =  ::flixel::math::FlxPoint_obj::__new((int)128,(int)128);
            	}
{
            	HX_STACK_FRAME("flixel.graphics.atlas.FlxAtlas","boot",0x7e06a0f3,"flixel.graphics.atlas.FlxAtlas.boot","flixel/graphics/atlas/FlxAtlas.hx",38,0x03972f50)
HXLINE(  38)		defaultMaxSize =  ::flixel::math::FlxPoint_obj::__new((int)1024,(int)1024);
            	}
}

} // end namespace flixel
} // end namespace graphics
} // end namespace atlas
