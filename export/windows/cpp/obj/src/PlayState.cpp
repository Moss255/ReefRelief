// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_Enemy
#include <Enemy.h>
#endif
#ifndef INCLUDED_LoseState
#include <LoseState.h>
#endif
#ifndef INCLUDED_MenuState
#include <MenuState.h>
#endif
#ifndef INCLUDED_Pickup
#include <Pickup.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_Player
#include <Player.h>
#endif
#ifndef INCLUDED_WinState
#include <WinState.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRandom
#include <flixel/math/FlxRandom.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemap
#include <flixel/tile/FlxTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemapAutoTiling
#include <flixel/tile/FlxTilemapAutoTiling.h>
#endif
#ifndef INCLUDED_flixel_util_FlxStringUtil
#include <flixel/util/FlxStringUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_openfl__legacy_Assets
#include <openfl/_legacy/Assets.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObject
#include <openfl/_legacy/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObjectContainer
#include <openfl/_legacy/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_InteractiveObject
#include <openfl/_legacy/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_Sprite
#include <openfl/_legacy/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_EventDispatcher
#include <openfl/_legacy/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_IEventDispatcher
#include <openfl/_legacy/events/IEventDispatcher.h>
#endif


void PlayState_obj::__construct( ::Dynamic MaxSize){
            	HX_STACK_FRAME("PlayState","new",0xf8bf96cf,"PlayState.new","PlayState.hx",13,0xb30d7781)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(MaxSize,"MaxSize")
HXLINE(  30)		this->_crateTotal = (int)0;
HXLINE(  29)		this->_score = (int)0;
HXLINE(  13)		super::__construct(MaxSize);
            	}

Dynamic PlayState_obj::__CreateEmpty() { return new PlayState_obj; }

hx::ObjectPtr< PlayState_obj > PlayState_obj::__new( ::Dynamic MaxSize)
{
	hx::ObjectPtr< PlayState_obj > _hx_result = new PlayState_obj();
	_hx_result->__construct(MaxSize);
	return _hx_result;
}

Dynamic PlayState_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< PlayState_obj > _hx_result = new PlayState_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

void PlayState_obj::create(){
            	HX_STACK_FRAME("PlayState","create",0x82220fed,"PlayState.create","PlayState.hx",35,0xb30d7781)
            	HX_STACK_THIS(this)
HXLINE(  36)		this->super::create();
HXLINE(  39)		::flixel::FlxG_obj::mouse->set_visible(false);
HXLINE(  41)		::flixel::FlxG_obj::game->_state->set_bgColor((int)-16246183);
HXLINE(  43)		this->_random =  ::flixel::math::FlxRandom_obj::__new(null());
HXLINE(  45)		this->_pickup = ::Array_obj< ::Dynamic>::__new();
HXLINE(  47)		this->_pickup->insert((int)0, ::Pickup_obj::__new((int)32,(int)148));
HXLINE(  48)		this->_pickup->insert((int)1, ::Pickup_obj::__new((int)84,(int)372));
HXLINE(  49)		this->_pickup->insert((int)2, ::Pickup_obj::__new((int)168,(int)436));
HXLINE(  50)		this->_pickup->insert((int)3, ::Pickup_obj::__new((int)532,(int)276));
HXLINE(  51)		this->_pickup->insert((int)4, ::Pickup_obj::__new((int)416,(int)180));
HXLINE(  52)		this->_pickup->insert((int)5, ::Pickup_obj::__new((int)544,(int)180));
HXLINE(  53)		this->_pickup->insert((int)6, ::Pickup_obj::__new((int)596,(int)372));
HXLINE(  54)		this->_pickup->insert((int)7, ::Pickup_obj::__new((int)388,(int)308));
HXLINE(  55)		this->_pickup->insert((int)8, ::Pickup_obj::__new((int)255,(int)281));
HXLINE(  56)		this->_pickup->insert((int)9, ::Pickup_obj::__new((int)180,(int)180));
HXLINE(  59)		this->_enemy = ::Array_obj< ::Dynamic>::__new();
HXLINE(  61)		this->_enemy->push( ::Enemy_obj::__new((int)65,(int)120));
HXLINE(  62)		 ::Enemy _hx_tmp = this->_enemy->__get((int)0).StaticCast<  ::Enemy >();
HXDLIN(  62)		this->add(_hx_tmp);
HXLINE(  64)		this->_crateTotal = this->_random->_hx_int((int)5,(int)9,null());
HXLINE(  66)		HX_VARI( ::Array< Int >,xNumbers) = ::Array_obj< Int >::__new();
HXLINE(  69)		{
HXLINE(  69)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  69)			HX_VARI( Int,_g) = this->_crateTotal;
HXDLIN(  69)			while((_g1 < _g)){
HXLINE(  69)				HX_VARI( Int,i) = _g1++;
HXLINE(  71)				Int _hx_tmp1 = this->_random->_hx_int((int)0,(int)9,xNumbers);
HXDLIN(  71)				xNumbers->push(_hx_tmp1);
HXLINE(  72)				 ::Pickup _hx_tmp2 = this->_pickup->__get(xNumbers->__get(i)).StaticCast<  ::Pickup >();
HXDLIN(  72)				this->add(_hx_tmp2);
            			}
            		}
HXLINE(  78)		this->_player =  ::Player_obj::__new();
HXLINE(  79)		this->add(this->_player);
HXLINE(  82)		this->_level =  ::flixel::tile::FlxTilemap_obj::__new();
HXLINE(  83)		 ::openfl::_legacy::display::BitmapData _hx_tmp3 = ::openfl::_legacy::Assets_obj::getBitmapData(HX_("assets/images/map.png",8c,89,cd,0a),null());
HXDLIN(  83)		::String _hx_tmp4 = ::flixel::util::FlxStringUtil_obj::bitmapToCSV(_hx_tmp3,false,(int)4,null());
HXDLIN(  83)		this->_level->loadMapFromCSV(_hx_tmp4,HX_("assets/images/tiles_2.png",28,37,3f,15),(int)8,(int)8,::flixel::tile::FlxTilemapAutoTiling_obj::ALT_dyn(),null(),null(),null());
HXLINE(  84)		this->_level->follow(null(),null(),null());
HXLINE(  85)		this->add(this->_level);
HXLINE(  88)		Int _hx_tmp5 = ::flixel::FlxG_obj::width;
HXDLIN(  88)		::String _hx_tmp6 = (HX_("Number of Crates: ",88,59,fd,90) + this->_score);
HXDLIN(  88)		this->_scoreText =  ::flixel::text::FlxText_obj::__new((int)10,(int)10,_hx_tmp5,_hx_tmp6,null(),null());
HXLINE(  89)		this->_scoreText->setFormat(HX_("assets/fonts/Oswald-Regular.ttf",e4,c6,d9,7e),(int)16,(int)-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),null(),null());
HXLINE(  90)		this->add(this->_scoreText);
HXLINE(  92)		Int _hx_tmp7 = ::flixel::FlxG_obj::width;
HXDLIN(  92)		Int _hx_tmp8 = this->_player->getLives();
HXDLIN(  92)		this->_livesText =  ::flixel::text::FlxText_obj::__new((int)300,(int)10,_hx_tmp7,(HX_("Lives: ",4d,9a,3a,88) + _hx_tmp8),null(),null());
HXLINE(  93)		this->_livesText->setFormat(HX_("assets/fonts/Oswald-Regular.ttf",e4,c6,d9,7e),(int)16,(int)-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),null(),null());
HXLINE(  94)		this->add(this->_livesText);
HXLINE(  96)		this->_popupText =  ::flixel::text::FlxText_obj::__new((int)0,(int)0,::flixel::FlxG_obj::width,HX_("",00,00,00,00),null(),null());
HXLINE(  97)		this->add(this->_popupText);
            	}


void PlayState_obj::update(Float elapsed){
            	HX_STACK_FRAME("PlayState","update",0x8d182efa,"PlayState.update","PlayState.hx",103,0xb30d7781)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(elapsed,"elapsed")
HXLINE( 106)		::flixel::FlxG_obj::overlap(this->_player,this->_level,null(),::flixel::FlxObject_obj::separate_dyn());
HXLINE( 109)		{
HXLINE( 109)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 109)			HX_VARI( Int,_g) = this->_pickup->length;
HXDLIN( 109)			while((_g1 < _g)){
HXLINE( 109)				HX_VARI( Int,i) = _g1++;
HXLINE( 111)				Bool _hx_tmp = this->_pickup->__get(i).StaticCast<  ::Pickup >()->isCollided(this->_player);
HXDLIN( 111)				if (_hx_tmp) {
HXLINE( 113)					this->_popupText->set_x(this->_player->x);
HXLINE( 114)					this->_popupText->set_y(this->_player->y);
HXLINE( 115)					this->_pickup->__get(i).StaticCast<  ::Pickup >()->destroy();
HXLINE( 116)					hx::AddEq(this->_score,(int)1);
HXLINE( 117)					::String _hx_tmp1 = ((this->_score + HX_(" / ",31,71,18,00)) + this->_crateTotal);
HXDLIN( 117)					this->_popupText->set_text(_hx_tmp1);
            				}
            			}
            		}
HXLINE( 125)		this->_enemy->__get((int)0).StaticCast<  ::Enemy >()->attack(this->_player);
HXLINE( 130)		HX_VARI(  ::flixel::input::keyboard::FlxKeyList,_this) = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 130)		Bool _hx_tmp2 = _this->keyManager->checkStatus((int)27,_this->status);
HXDLIN( 130)		if (_hx_tmp2) {
HXLINE( 132)			HX_VARI(  ::flixel::FlxState,nextState) =  ::MenuState_obj::__new(null());
HXDLIN( 132)			Bool _hx_tmp3 = ::flixel::FlxG_obj::game->_state->switchTo(nextState);
HXDLIN( 132)			if (_hx_tmp3) {
HXLINE( 132)				::flixel::FlxG_obj::game->_requestedState = nextState;
            			}
            		}
HXLINE( 135)		HX_VARI_NAME(  ::flixel::input::keyboard::FlxKeyList,_this1,"_this") = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 135)		Bool _hx_tmp4 = _this1->keyManager->checkStatus((int)115,_this1->status);
HXDLIN( 135)		if (_hx_tmp4) {
HXLINE( 138)			Bool _hx_tmp5 = ::flixel::FlxG_obj::get_fullscreen();
HXDLIN( 138)			if ((_hx_tmp5 == true)) {
HXLINE( 139)				::flixel::FlxG_obj::set_fullscreen(false);
            			}
            			else {
HXLINE( 141)				::flixel::FlxG_obj::set_fullscreen(true);
            			}
            		}
HXLINE( 144)		::String _hx_tmp6 = (HX_("Number of Crates: ",88,59,fd,90) + this->_score);
HXDLIN( 144)		this->_scoreText->set_text(_hx_tmp6);
HXLINE( 146)		Int _hx_tmp7 = this->_player->getLives();
HXDLIN( 146)		this->_livesText->set_text((HX_("Lives: ",4d,9a,3a,88) + _hx_tmp7));
HXLINE( 148)		Bool _hx_tmp8 = (this->_score == this->_crateTotal);
HXDLIN( 148)		if (_hx_tmp8) {
HXLINE( 150)			HX_VARI_NAME(  ::flixel::FlxState,nextState1,"nextState") =  ::WinState_obj::__new(null());
HXDLIN( 150)			Bool _hx_tmp9 = ::flixel::FlxG_obj::game->_state->switchTo(nextState1);
HXDLIN( 150)			if (_hx_tmp9) {
HXLINE( 150)				::flixel::FlxG_obj::game->_requestedState = nextState1;
            			}
            		}
HXLINE( 153)		Int _hx_tmp10 = this->_player->getLives();
HXDLIN( 153)		if ((_hx_tmp10 == (int)0)) {
HXLINE( 155)			HX_VARI_NAME(  ::flixel::FlxState,nextState2,"nextState") =  ::LoseState_obj::__new(null());
HXDLIN( 155)			Bool _hx_tmp11 = ::flixel::FlxG_obj::game->_state->switchTo(nextState2);
HXDLIN( 155)			if (_hx_tmp11) {
HXLINE( 155)				::flixel::FlxG_obj::game->_requestedState = nextState2;
            			}
            		}
HXLINE( 159)		this->super::update(elapsed);
            	}



PlayState_obj::PlayState_obj()
{
}

void PlayState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PlayState);
	HX_MARK_MEMBER_NAME(_level,"_level");
	HX_MARK_MEMBER_NAME(_player,"_player");
	HX_MARK_MEMBER_NAME(_scoreText,"_scoreText");
	HX_MARK_MEMBER_NAME(_popupText,"_popupText");
	HX_MARK_MEMBER_NAME(_livesText,"_livesText");
	HX_MARK_MEMBER_NAME(_pickup,"_pickup");
	HX_MARK_MEMBER_NAME(_enemy,"_enemy");
	HX_MARK_MEMBER_NAME(_score,"_score");
	HX_MARK_MEMBER_NAME(_crateTotal,"_crateTotal");
	HX_MARK_MEMBER_NAME(_random,"_random");
	 ::flixel::FlxState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PlayState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_level,"_level");
	HX_VISIT_MEMBER_NAME(_player,"_player");
	HX_VISIT_MEMBER_NAME(_scoreText,"_scoreText");
	HX_VISIT_MEMBER_NAME(_popupText,"_popupText");
	HX_VISIT_MEMBER_NAME(_livesText,"_livesText");
	HX_VISIT_MEMBER_NAME(_pickup,"_pickup");
	HX_VISIT_MEMBER_NAME(_enemy,"_enemy");
	HX_VISIT_MEMBER_NAME(_score,"_score");
	HX_VISIT_MEMBER_NAME(_crateTotal,"_crateTotal");
	HX_VISIT_MEMBER_NAME(_random,"_random");
	 ::flixel::FlxState_obj::__Visit(HX_VISIT_ARG);
}

hx::Val PlayState_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"_level") ) { return hx::Val( _level); }
		if (HX_FIELD_EQ(inName,"_enemy") ) { return hx::Val( _enemy); }
		if (HX_FIELD_EQ(inName,"_score") ) { return hx::Val( _score); }
		if (HX_FIELD_EQ(inName,"create") ) { return hx::Val( create_dyn()); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_player") ) { return hx::Val( _player); }
		if (HX_FIELD_EQ(inName,"_pickup") ) { return hx::Val( _pickup); }
		if (HX_FIELD_EQ(inName,"_random") ) { return hx::Val( _random); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_scoreText") ) { return hx::Val( _scoreText); }
		if (HX_FIELD_EQ(inName,"_popupText") ) { return hx::Val( _popupText); }
		if (HX_FIELD_EQ(inName,"_livesText") ) { return hx::Val( _livesText); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_crateTotal") ) { return hx::Val( _crateTotal); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val PlayState_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"_level") ) { _level=inValue.Cast<  ::flixel::tile::FlxTilemap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_enemy") ) { _enemy=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_score") ) { _score=inValue.Cast< Int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_player") ) { _player=inValue.Cast<  ::Player >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_pickup") ) { _pickup=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_random") ) { _random=inValue.Cast<  ::flixel::math::FlxRandom >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_scoreText") ) { _scoreText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_popupText") ) { _popupText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_livesText") ) { _livesText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_crateTotal") ) { _crateTotal=inValue.Cast< Int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void PlayState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("_level","\xc5","\x5c","\x4a","\x6e"));
	outFields->push(HX_HCSTRING("_player","\x00","\xfd","\x2f","\xa6"));
	outFields->push(HX_HCSTRING("_scoreText","\xe0","\xf8","\x5f","\x38"));
	outFields->push(HX_HCSTRING("_popupText","\xba","\x04","\xf9","\x1f"));
	outFields->push(HX_HCSTRING("_livesText","\x15","\x74","\x03","\xcb"));
	outFields->push(HX_HCSTRING("_pickup","\x1b","\x1b","\x44","\xed"));
	outFields->push(HX_HCSTRING("_enemy","\x89","\x59","\x62","\x6c"));
	outFields->push(HX_HCSTRING("_score","\x93","\xba","\xc0","\x74"));
	outFields->push(HX_HCSTRING("_crateTotal","\x20","\x2d","\x19","\xac"));
	outFields->push(HX_HCSTRING("_random","\xa2","\x33","\x06","\x26"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo PlayState_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::flixel::tile::FlxTilemap*/ ,(int)offsetof(PlayState_obj,_level),HX_HCSTRING("_level","\xc5","\x5c","\x4a","\x6e")},
	{hx::fsObject /*::Player*/ ,(int)offsetof(PlayState_obj,_player),HX_HCSTRING("_player","\x00","\xfd","\x2f","\xa6")},
	{hx::fsObject /*::flixel::text::FlxText*/ ,(int)offsetof(PlayState_obj,_scoreText),HX_HCSTRING("_scoreText","\xe0","\xf8","\x5f","\x38")},
	{hx::fsObject /*::flixel::text::FlxText*/ ,(int)offsetof(PlayState_obj,_popupText),HX_HCSTRING("_popupText","\xba","\x04","\xf9","\x1f")},
	{hx::fsObject /*::flixel::text::FlxText*/ ,(int)offsetof(PlayState_obj,_livesText),HX_HCSTRING("_livesText","\x15","\x74","\x03","\xcb")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(PlayState_obj,_pickup),HX_HCSTRING("_pickup","\x1b","\x1b","\x44","\xed")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(PlayState_obj,_enemy),HX_HCSTRING("_enemy","\x89","\x59","\x62","\x6c")},
	{hx::fsInt,(int)offsetof(PlayState_obj,_score),HX_HCSTRING("_score","\x93","\xba","\xc0","\x74")},
	{hx::fsInt,(int)offsetof(PlayState_obj,_crateTotal),HX_HCSTRING("_crateTotal","\x20","\x2d","\x19","\xac")},
	{hx::fsObject /*::flixel::math::FlxRandom*/ ,(int)offsetof(PlayState_obj,_random),HX_HCSTRING("_random","\xa2","\x33","\x06","\x26")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *PlayState_obj_sStaticStorageInfo = 0;
#endif

static ::String PlayState_obj_sMemberFields[] = {
	HX_HCSTRING("_level","\xc5","\x5c","\x4a","\x6e"),
	HX_HCSTRING("_player","\x00","\xfd","\x2f","\xa6"),
	HX_HCSTRING("_scoreText","\xe0","\xf8","\x5f","\x38"),
	HX_HCSTRING("_popupText","\xba","\x04","\xf9","\x1f"),
	HX_HCSTRING("_livesText","\x15","\x74","\x03","\xcb"),
	HX_HCSTRING("_pickup","\x1b","\x1b","\x44","\xed"),
	HX_HCSTRING("_enemy","\x89","\x59","\x62","\x6c"),
	HX_HCSTRING("_score","\x93","\xba","\xc0","\x74"),
	HX_HCSTRING("_crateTotal","\x20","\x2d","\x19","\xac"),
	HX_HCSTRING("_random","\xa2","\x33","\x06","\x26"),
	HX_HCSTRING("create","\xfc","\x66","\x0f","\x7c"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	::String(null()) };

static void PlayState_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(PlayState_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void PlayState_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(PlayState_obj::__mClass,"__mClass");
};

#endif

hx::Class PlayState_obj::__mClass;

void PlayState_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("PlayState","\x5d","\x83","\xc2","\x46");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = PlayState_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(PlayState_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< PlayState_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = PlayState_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PlayState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PlayState_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

